<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicalSystemsBase.jl · DynamicalSystemsBase.jl</title><meta name="title" content="DynamicalSystemsBase.jl · DynamicalSystemsBase.jl"/><meta property="og:title" content="DynamicalSystemsBase.jl · DynamicalSystemsBase.jl"/><meta property="twitter:title" content="DynamicalSystemsBase.jl · DynamicalSystemsBase.jl"/><meta name="description" content="Documentation for DynamicalSystemsBase.jl."/><meta property="og:description" content="Documentation for DynamicalSystemsBase.jl."/><meta property="twitter:description" content="Documentation for DynamicalSystemsBase.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DynamicalSystemsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DynamicalSystemsBase.jl</a><ul class="internal"><li><a class="tocitem" href="#The-DynamicalSystem-API"><span>The <code>DynamicalSystem</code> API</span></a></li><li><a class="tocitem" href="#Time-evolution"><span>Time evolution</span></a></li><li><a class="tocitem" href="#DeterministicIteratedMap"><span><code>DeterministicIteratedMap</code></span></a></li><li><a class="tocitem" href="#CoupledODEs"><span><code>CoupledODEs</code></span></a></li><li><a class="tocitem" href="#StroboscopicMap"><span><code>StroboscopicMap</code></span></a></li><li><a class="tocitem" href="#PoincareMap"><span><code>PoincareMap</code></span></a></li><li><a class="tocitem" href="#TangentDynamicalSystem"><span><code>TangentDynamicalSystem</code></span></a></li><li><a class="tocitem" href="#ProjectedDynamicalSystem"><span><code>ProjectedDynamicalSystem</code></span></a></li><li><a class="tocitem" href="#ParallelDynamicalSystem"><span><code>ParallelDynamicalSystem</code></span></a></li><li><a class="tocitem" href="#ArbitrarySteppable"><span><code>ArbitrarySteppable</code></span></a></li><li><a class="tocitem" href="#Parallelization"><span>Parallelization</span></a></li><li><a class="tocitem" href="#Advanced-example"><span>Advanced example</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DynamicalSystemsBase.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicalSystemsBase.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicalSystemsBase.jl"><a class="docs-heading-anchor" href="#DynamicalSystemsBase.jl">DynamicalSystemsBase.jl</a><a id="DynamicalSystemsBase.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicalSystemsBase.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase" href="#DynamicalSystemsBase"><code>DynamicalSystemsBase</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DynamicalSystemsBase.jl</strong></p><p><a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystemsbase/dev/"><img src="https://img.shields.io/badge/docs-dev-lightblue.svg" alt="docsdev"/></a> <a href="https://juliadynamics.github.io/DynamicalSystemsDocs.jl/dynamicalsystemsbase/stable/"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="docsstable"/></a> <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7"><img src="https://img.shields.io/badge/DOI-10.1007%2F978--3--030--91032--7-purple" alt/></a> <a href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/JuliaDynamics/DynamicalSystemsBase.jl"><img src="https://codecov.io/gh/JuliaDynamics/DynamicalSystemsBase.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://pkgs.genieframework.com?packages=DynamicalSystemsBase"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/DynamicalSystemsBase" alt="Package Downloads"/></a></p><p>A Julia package that defines the <code>DynamicalSystem</code> interface and many concrete implementations used in the DynamicalSystems.jl ecosystem.</p><p>To install it, run <code>import Pkg; Pkg.add(&quot;DynamicalSystemsBase&quot;)</code>. Typically, you do not want to use <code>DynamicalSystemsBase</code> directly, as downstream analysis packages re-export it.</p><p>All further information is provided in the documentation, which you can either find online or build locally by running the <code>docs/make.jl</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/DynamicalSystemsBase.jl#L4-L21">source</a></section></article><p>!!! note &quot;Tutorial and examples at DynamicalSystems.jl docs!     Please visit the documentation of the main DynamicalSystems.jl docs for a tutorial and examples on using the interface.</p><h2 id="The-DynamicalSystem-API"><a class="docs-heading-anchor" href="#The-DynamicalSystem-API">The <code>DynamicalSystem</code> API</a><a id="The-DynamicalSystem-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-DynamicalSystem-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicalSystem</code></pre><p><code>DynamicalSystem</code> is an abstract supertype encompassing all concrete implementations of what counts as a &quot;dynamical system&quot; in the DynamicalSystems.jl library.</p><p><strong><em>All concrete implementations of <code>DynamicalSystem</code> can be iteratively evolved in time via the <a href="#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> function.</em></strong> Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has for parallelization.</p><p><code>DynamicalSystem</code> is further separated into two abstract types: <code>ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem</code>. The simplest and most common concrete implementations of a <code>DynamicalSystem</code> are <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>.</p><p><strong>Description</strong></p><p>A <code>DynamicalSystem</code> <strong>represents the time evolution of a state in a state space</strong>. It mainly encapsulates three things:</p><ol><li>A state, typically referred to as <code>u</code>, with initial value <code>u0</code>. The space that <code>u</code> occupies is the state space of <code>ds</code> and the length of <code>u</code> is the dimension of <code>ds</code> (and of the state space).</li><li>A dynamic rule, typically referred to as <code>f</code>, that dictates how the state evolves/changes with time when calling the <a href="#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> function. <code>f</code> is typically a standard Julia function, see the online documentation for examples.</li><li>A parameter container <code>p</code> that parameterizes <code>f</code>. <code>p</code> can be anything, but in general it is recommended to be a type-stable mutable container.</li></ol><p>In sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of <code>DynamicalSystem</code> are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.</p><p>In this scope dynamical systems have a known dynamic rule <code>f</code>. Finite <em>measured</em> or <em>sampled</em> data from a dynamical system are represented using <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>. Such data are obtained from the <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> function or from an experimental measurement of a dynamical system with an unknown dynamic rule.</p><p>See also the DynamicalSystems.jl tutorial online for examples making dynamical systems.</p><p><strong>Integration with ModelingToolkit.jl</strong></p><p>Dynamical systems that have been constructed from <code>DEProblem</code>s that themselves have been constructed from ModelingToolkit.jl keep a reference to the symbolic model and all symbolic variables. Accessing a <code>DynamicalSystem</code> using symbolic variables is possible via the functions <a href="#DynamicalSystemsBase.observe_state"><code>observe_state</code></a>, <a href="#DynamicalSystemsBase.set_state!"><code>set_state!</code></a>, <a href="#DynamicalSystemsBase.current_parameter"><code>current_parameter</code></a> and <a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a>. The referenced MTK model corresponding to the dynamical system can be obtained with <code>model = referrenced_sciml_model(ds::DynamicalSystem)</code>.</p><p>See also the DynamicalSystems.jl tutorial online for an example.</p><p><strong>API</strong></p><p>The API that <code>DynamicalSystem</code> employs is composed of the functions listed below. Once a concrete instance of a subtype of <code>DynamicalSystem</code> is obtained, it can queried or altered with the following functions.</p><p>The main use of a concrete dynamical system instance is to provide it to downstream functions such as <code>lyapunovspectrum</code> from ChaosTools.jl or <code>basins_of_attraction</code> from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.</p><p><strong>API - obtain information</strong></p><ul><li><code>ds(t)</code> with <code>ds</code> an instance of <code>DynamicalSystem</code>: return the state of <code>ds</code> at time <code>t</code>. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if <code>t</code> is the current time.</li><li><a href="#DynamicalSystemsBase.current_state"><code>current_state</code></a></li><li><a href="#DynamicalSystemsBase.initial_state"><code>initial_state</code></a></li><li><a href="#DynamicalSystemsBase.observe_state"><code>observe_state</code></a></li><li><a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a></li><li><a href="#DynamicalSystemsBase.current_parameter"><code>current_parameter</code></a></li><li><a href="#DynamicalSystemsBase.initial_parameters"><code>initial_parameters</code></a></li><li><a href="#DynamicalSystemsBase.isdeterministic"><code>isdeterministic</code></a></li><li><a href="#DynamicalSystemsBase.isdiscretetime"><code>isdiscretetime</code></a></li><li><a href="#DynamicalSystemsBase.dynamic_rule"><code>dynamic_rule</code></a></li><li><a href="#DynamicalSystemsBase.current_time"><code>current_time</code></a></li><li><a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a></li><li><a href="#SciMLBase.isinplace-Tuple{DynamicalSystem}"><code>isinplace</code></a></li><li><a href="#DynamicalSystemsBase.successful_step"><code>successful_step</code></a></li><li><a href="#DynamicalSystemsBase.referrenced_sciml_model"><code>referrenced_sciml_model</code></a></li></ul><p><strong>API - alter status</strong></p><ul><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a></li><li><a href="#DynamicalSystemsBase.set_state!"><code>set_state!</code></a></li><li><a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a></li><li><a href="#DynamicalSystemsBase.set_parameters!"><code>set_parameters!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L4-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_state" href="#DynamicalSystemsBase.current_state"><code>DynamicalSystemsBase.current_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_state(ds::DynamicalSystem) → u::AbstractArray</code></pre><p>Return the current state of <code>ds</code>. This state is mutated when <code>ds</code> is mutated. See also <a href="#DynamicalSystemsBase.initial_state"><code>initial_state</code></a>, <a href="#DynamicalSystemsBase.observe_state"><code>observe_state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.initial_state" href="#DynamicalSystemsBase.initial_state"><code>DynamicalSystemsBase.initial_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_state(ds::DynamicalSystem) → u0</code></pre><p>Return the initial state of <code>ds</code>. This state is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L200-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.observe_state" href="#DynamicalSystemsBase.observe_state"><code>DynamicalSystemsBase.observe_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">observe_state(ds::DynamicalSystem, i [,u = current_state(ds)]) → x::Real</code></pre><p>Return the state <code>u</code> of <code>ds</code> <em>observed</em> at &quot;index&quot; <code>i</code>. Possibilities are:</p><ul><li><code>i::Int</code> returns the <code>i</code>-th dynamic variable.</li><li><code>i::Function</code> returns <code>f(current_state(ds))</code>, which is asserted to be a real number.</li><li><code>i::SymbolLike</code> returns the value of the corresponding symbolic variable.  This is valid only for dynamical systems referrencing a ModelingToolkit.jl model  which also has <code>i</code> as one of its listed variables. This can be a formal state variable  or an &quot;observed&quot; variable according to ModelingToolkit.jl. In short, it can be anything  that could index the solution object <code>sol = ModelingToolkit.solve(...)</code>.</li></ul><p>For <a href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a>, this function assumes that the state of the system is the full state space state, not the projected one (this makes the most sense for allowing MTK-based indexing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L165-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_parameters" href="#DynamicalSystemsBase.current_parameters"><code>DynamicalSystemsBase.current_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_parameters(ds::DynamicalSystem) → p</code></pre><p>Return the current parameter container of <code>ds</code>. This is mutated in functions that need to evolve <code>ds</code> across a parameter range.</p><p>See also <a href="#DynamicalSystemsBase.initial_parameters"><code>initial_parameters</code></a>, <a href="#DynamicalSystemsBase.current_parameter"><code>current_parameter</code></a>, <a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L208-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_parameter" href="#DynamicalSystemsBase.current_parameter"><code>DynamicalSystemsBase.current_parameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_parameter(ds::DynamicalSystem, index [,p])</code></pre><p>Return the specific parameter of <code>ds</code> corresponding to <code>index</code>, which can be anything given to <a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a>. <code>p</code> defaults to <a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a> and is the parameter container to extract the parameter from, which must match layout with its default value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.initial_parameters" href="#DynamicalSystemsBase.initial_parameters"><code>DynamicalSystemsBase.initial_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_parameters(ds::DynamicalSystem) → p0</code></pre><p>Return the initial parameter container of <code>ds</code>. This is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.isdeterministic" href="#DynamicalSystemsBase.isdeterministic"><code>DynamicalSystemsBase.isdeterministic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdeterministic(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if <code>ds</code> is deterministic, i.e., the dynamic rule contains no randomness. This is information deduced from the type of <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.isdiscretetime" href="#DynamicalSystemsBase.isdiscretetime"><code>DynamicalSystemsBase.isdiscretetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdiscretetime(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if <code>ds</code> operates in discrete time, or <code>false</code> if it is in continuous time. This is information deduced from the type of <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.dynamic_rule" href="#DynamicalSystemsBase.dynamic_rule"><code>DynamicalSystemsBase.dynamic_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_rule(ds::DynamicalSystem) → f</code></pre><p>Return the dynamic rule of <code>ds</code>. This is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L264-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_time" href="#DynamicalSystemsBase.current_time"><code>DynamicalSystemsBase.current_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_time(ds::DynamicalSystem) → t</code></pre><p>Return the current time that <code>ds</code> is at. This is mutated when <code>ds</code> is evolved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L272-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.initial_time" href="#DynamicalSystemsBase.initial_time"><code>DynamicalSystemsBase.initial_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_time(ds::DynamicalSystem) → t0</code></pre><p>Return the initial time defined for <code>ds</code>. This is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L279-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.isinplace-Tuple{DynamicalSystem}" href="#SciMLBase.isinplace-Tuple{DynamicalSystem}"><code>SciMLBase.isinplace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinplace(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if the dynamic rule of <code>ds</code> is in-place, i.e., a function mutating the state in place. If <code>true</code>, the state is typically <code>Array</code>, if <code>false</code>, the state is typically <code>SVector</code>. A front-end user will most likely not care about this information, but a developer may care.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L287-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.successful_step" href="#DynamicalSystemsBase.successful_step"><code>DynamicalSystemsBase.successful_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">successful_step(ds::DynamicalSystem) -&gt; true/false</code></pre><p>Return <code>true</code> if the last <code>step!</code> call to <code>ds</code> was successful, <code>false</code> otherwise. For continuous time systems this uses DifferentialEquations.jl error checking, for discrete time it checks if any variable is <code>Inf</code> or <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L297-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.referrenced_sciml_model" href="#DynamicalSystemsBase.referrenced_sciml_model"><code>DynamicalSystemsBase.referrenced_sciml_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">referrenced_sciml_model(ds::DynamicalSystem)</code></pre><p>Return the ModelingToolkit.jl structurally-simplified model referrenced by <code>ds</code>. Return <code>nothing</code> if there is no referrenced model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}" href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>SciMLBase.reinit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds</code></pre><p>Reset the status of <code>ds</code>, so that it is as if it has be just initialized with initial state <code>u</code>. Practically every function of the ecosystem that evolves <code>ds</code> first calls this function on it. Besides the new initial state <code>u</code>, you can also configure the keywords <code>t0 = initial_time(ds)</code> and <code>p = current_parameters(ds)</code>.</p><p>Note the default settings: the state and time are the initial, but the parameters are the current.</p><p>The special method <code>reinit!(ds, ::Nothing; kwargs...)</code> is also available, which does nothing and leaves the system as is. This is so that downstream functions that call <code>reinit!</code> can still be used without resetting the system but rather continuing from its exact current state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L427-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.set_state!" href="#DynamicalSystemsBase.set_state!"><code>DynamicalSystemsBase.set_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_state!(ds::DynamicalSystem, u::AbstractArray)</code></pre><p>Set the state of <code>ds</code> to <code>u</code>, which must match dimensionality with that of <code>ds</code>. Also ensure that the change is notified to whatever integration protocol is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L314-L319">source</a></section><section><div><pre><code class="language-julia hljs">set_state!(ds::DynamicalSystem, value::Real, index) → u</code></pre><p>Set the <code>i</code>th variable of <code>ds</code> to <code>value</code>. The <code>index</code> can be an integer or a symbolic variable that is a state variable for systems that reference a ModelingToolkit.jl model.</p><p>Calling instead <code>set_state!(u, value, index, ds)</code> will modify the given state <code>u</code> and return it, leaving <code>ds</code> unaltered.</p><p><strong>Warning:</strong> this function should not be used with derivative dynamical systems such as Poincare/stroboscopic/projected dynamical systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L322-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.set_parameter!" href="#DynamicalSystemsBase.set_parameter!"><code>DynamicalSystemsBase.set_parameter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_parameter!(ds::DynamicalSystem, index, value [, p])</code></pre><p>Change a parameter of <code>ds</code> given the <code>index</code> it has in the parameter container and the <code>value</code> to set it to. This function works for any type of parameter container (array/dictionary/composite types) provided the <code>index</code> is appropriate type.</p><p>The <code>index</code> can be a traditional Julia index (integer for arrays, key for dictionaries, or symbol for composite types). It can also be a symbolic variable. This is valid only for dynamical systems referring a ModelingToolkit.jl model which also has <code>index</code> as one of its parameters.</p><p>The last optional argument <code>p</code> defaults to <a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a> and is the parameter container whose value is changed at the given index. It must match layout with its default value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L355-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.set_parameters!" href="#DynamicalSystemsBase.set_parameters!"><code>DynamicalSystemsBase.set_parameters!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_parameters!(ds::DynamicalSystem, p = initial_parameters(ds))</code></pre><p>Set the parameter values in the <a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a><code>(ds)</code> to match <code>p</code>. This is done as an in-place overwrite by looping over the keys of <code>p</code>. Hence the keys of <code>p</code> must be a subset of the keys of <a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a><code>(ds)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L390-L396">source</a></section></article><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}" href="#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>CommonSolve.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(ds::DiscreteTimeDynamicalSystem [, n::Integer]) → ds</code></pre><p>Evolve the discrete time dynamical system for 1 or <code>n</code> steps.</p><pre><code class="nohighlight hljs">step!(ds::ContinuousTimeDynamicalSystem, [, dt::Real [, stop_at_tdt]]) → ds</code></pre><p>Evolve the continuous time dynamical system for one integration step.</p><p>Alternatively, if a <code>dt</code> is given, then progress the integration until there is a temporal difference <code>≥ dt</code> (so, step <em>at least</em> for <code>dt</code> time).</p><p>When <code>true</code> is passed to the optional third argument, the integration advances for exactly <code>dt</code> time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/dynamicalsystem_interface.jl#L410-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.trajectory" href="#DynamicalSystemsBase.trajectory"><code>DynamicalSystemsBase.trajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trajectory(ds::DynamicalSystem, T [, u0]; kwargs...) → X, t</code></pre><p>Evolve <code>ds</code> for a total time of <code>T</code> and return its trajectory <code>X</code>, sampled at equal time intervals, and corresponding time vector. Optionally provide a starting state <code>u0</code> which is <code>current_state(ds)</code> by default.</p><p>The returned time vector is <code>t = (t0+Ttr):Δt:(t0+Ttr+T)</code>.</p><p>If time evolution diverged before <code>T</code>, the remaining of the trajectory is set to the last valid point.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Δt</code>:  Time step of value output. For discrete time systems it must be an integer. Defaults to <code>0.1</code> for continuous and <code>1</code> for discrete time systems. If you don&#39;t have access to unicode, the keyword <code>Dt</code> can be used instead.</li><li><code>Ttr = 0</code>: Transient time to evolve the initial state before starting saving states.</li><li><code>t0 = initial_time(ds)</code>: Starting time.</li><li><code>save_idxs::AbstractVector{Int}</code>: Which variables to output in <code>X</code> (by default all).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core/trajectory.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.StateSpaceSet" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T} &lt;: AbstractStateSpaceSet{D,T}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>. Each point is represented by <code>SVector{D, T}</code>. The data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(ssset::StateSpaceSet)</code>. Typically the order of points in the set is the time direction, but it doesn&#39;t have to be.</p><p>When indexed with 1 index, <code>StateSpaceSet</code> is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.</p><p><code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/statespaceset_concrete.jl#L3-L41">source</a></section></article><h2 id="DeterministicIteratedMap"><a class="docs-heading-anchor" href="#DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a><a id="DeterministicIteratedMap-1"></a><a class="docs-heading-anchor-permalink" href="#DeterministicIteratedMap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.DeterministicIteratedMap" href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DynamicalSystemsBase.DeterministicIteratedMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeterministicIteratedMap &lt;: DynamicalSystem
DeterministicIteratedMap(f, u0, p = nothing; t0 = 0)</code></pre><p>A deterministic discrete time dynamical system defined by an iterated map as follows:</p><p class="math-container">\[\vec{u}_{n+1} = \vec{f}(\vec{u}_n, p, n)\]</p><p>An alias for <code>DeterministicIteratedMap</code> is <code>DiscreteDynamicalSystem</code>.</p><p>Optionally configure the parameter container <code>p</code> and initial time <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see the DynamicalSystems.jl tutorial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core_systems/discrete_time_map.jl#L7-L20">source</a></section></article><h2 id="CoupledODEs"><a class="docs-heading-anchor" href="#CoupledODEs"><code>CoupledODEs</code></a><a id="CoupledODEs-1"></a><a class="docs-heading-anchor-permalink" href="#CoupledODEs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.CoupledODEs" href="#DynamicalSystemsBase.CoupledODEs"><code>DynamicalSystemsBase.CoupledODEs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoupledODEs &lt;: ContinuousTimeDynamicalSystem
CoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)</code></pre><p>A deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:</p><p class="math-container">\[\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}, p, t)\]</p><p>An alias for <code>CoupledODE</code> is <code>ContinuousDynamicalSystem</code>.</p><p>Optionally provide the parameter container <code>p</code> and initial time as keyword <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see the DynamicalSystems.jl tutorial.</p><p><strong>DifferentialEquations.jl interfacing</strong></p><p>The ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a <code>CoupledODEs</code>, you can specify the solver that will integrate <code>f</code> in time, along with any other integration options, using the <code>diffeq</code> keyword. For example you could use <code>diffeq = (abstol = 1e-9, reltol = 1e-9)</code>. If you want to specify a solver, do so by using the keyword <code>alg</code>, e.g.: <code>diffeq = (alg = Tsit5(), reltol = 1e-6)</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers. The default <code>diffeq</code> is:</p><p>(alg = Tsit5(; stage<em>limiter! = trivial</em>limiter!, step<em>limiter! = trivial</em>limiter!, thread = static(false),), abstol = 1.0e-6, reltol = 1.0e-6)</p><p><code>diffeq</code> keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling </a>.</p><p>The convenience constructors <code>CoupledODEs(prob::ODEProblem [, diffeq])</code> and <code>CoupledODEs(ds::CoupledODEs [, diffeq])</code> are also available. To integrate with ModelingToolkit.jl, the dynamical system <strong>must</strong> be created via the <code>ODEProblem</code> (which itself is created via ModelingToolkit.jl), see the Tutorial for an example.</p><p>Dev note: <code>CoupledODEs</code> is a light wrapper of <code>ODEIntegrator</code> from DifferentialEquations.jl. The integrator is available as the field <code>integ</code>, and the <code>ODEProblem</code> is <code>integ.sol.prob</code>. The convenience syntax <code>ODEProblem(ds::CoupledODEs, tspan = (t0, Inf))</code> is available to extract the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core_systems/continuous_time_ode.jl#L26-L66">source</a></section></article><h2 id="StroboscopicMap"><a class="docs-heading-anchor" href="#StroboscopicMap"><code>StroboscopicMap</code></a><a id="StroboscopicMap-1"></a><a class="docs-heading-anchor-permalink" href="#StroboscopicMap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.StroboscopicMap" href="#DynamicalSystemsBase.StroboscopicMap"><code>DynamicalSystemsBase.StroboscopicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StroboscopicMap &lt;: DiscreteTimeDynamicalSystem
StroboscopicMap(ds::CoupledODEs, period::Real) → smap
StroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)</code></pre><p>A discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> system exactly over a given <code>period</code>. The second signature first creates a <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> and then calls the first.</p><p><code>StroboscopicMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface. In addition, the function <code>set_period!(smap, period)</code> is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, <a href="#DynamicalSystemsBase.current_time"><code>current_time</code></a> and <a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a> are integers. The initial time is always 0, because <code>current_time</code> counts elapsed periods. Call these functions on the <code>parent</code> of <code>StroboscopicMap</code> to obtain the corresponding continuous time. In contrast, <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> expects <code>t0</code> in continuous time.</p><p>The convenience constructor</p><pre><code class="language-julia hljs">StroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap</code></pre><p>is also provided.</p><p>See also <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/stroboscopic_map.jl#L6-L31">source</a></section></article><h2 id="PoincareMap"><a class="docs-heading-anchor" href="#PoincareMap"><code>PoincareMap</code></a><a id="PoincareMap-1"></a><a class="docs-heading-anchor-permalink" href="#PoincareMap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.PoincareMap" href="#DynamicalSystemsBase.PoincareMap"><code>DynamicalSystemsBase.PoincareMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoincareMap &lt;: DiscreteTimeDynamicalSystem
PoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap</code></pre><p>A discrete time dynamical system that produces iterations over the Poincaré map<sup class="footnote-reference"><a id="citeref-DatserisParlitz2022" href="#footnote-DatserisParlitz2022">[DatserisParlitz2022]</a></sup> of the given continuous time <code>ds</code>. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the <code>plane</code> argument.</p><p>See also <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a>, <a href="#DynamicalSystemsBase.poincaresos"><code>poincaresos</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>direction = -1</code>: Only crossings with <code>sign(direction)</code> are considered to belong to the surface of section. Negative direction means going from less than <span>$b$</span> to greater than <span>$b$</span>.</li><li><code>u0 = nothing</code>: Specify an initial state.</li><li><code>rootkw = (xrtol = 1e-6, atol = 1e-8)</code>: A <code>NamedTuple</code> of keyword arguments passed to <code>find_zero</code> from <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a>.</li><li><code>Tmax = 1e3</code>: The argument <code>Tmax</code> exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one <code>step!</code> the system has been evolved for more than <code>Tmax</code>, then <code>step!(pmap)</code> will terminate and error.</li></ul><p><strong>Description</strong></p><p>The Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. <code>PoincareMap</code> iterates over the crossings of the section.</p><p>If the state of <code>ds</code> is <span>$\mathbf{u} = (u_1, \ldots, u_D)$</span> then the equation defining a hyperplane is</p><p class="math-container">\[a_1u_1 + \dots + a_Du_D = \mathbf{a}\cdot\mathbf{u}=b\]</p><p>where <span>$\mathbf{a}, b$</span> are the parameters of the hyperplane.</p><p>In code, <code>plane</code> can be either:</p><ul><li>A <code>Tuple{Int, &lt;: Real}</code>, like <code>(j, r)</code>: the plane is defined as when the <code>j</code>th variable of the system equals the value <code>r</code>.</li><li>A vector of length <code>D+1</code>. The first <code>D</code> elements of the vector correspond to <span>$\mathbf{a}$</span> while the last element is <span>$b$</span>.</li></ul><p><code>PoincareMap</code> uses <code>ds</code>, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.</p><p><code>PoincareMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ol><li><code>dimension(pmap) == dimension(ds)</code>, even though the Poincaré map is effectively 1 dimension less.</li><li>Like <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a> time is discrete and counts the iterations on the surface of section. <a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a> is always <code>0</code> and <a href="#DynamicalSystemsBase.current_time"><code>current_time</code></a> is current iteration number.</li><li>A new function <a href="#DynamicalSystemsBase.current_crossing_time"><code>current_crossing_time</code></a> returns the real time corresponding to the latest crossing of the hyperplane, which is what the <a href="#DynamicalSystemsBase.current_state"><code>current_state(ds)</code></a> corresponds to as well.</li><li>For the special case of <code>plane</code> being a <code>Tuple{Int, &lt;:Real}</code>, a special <code>reinit!</code> method is allowed with input state of length <code>D-1</code> instead of <code>D</code>, i.e., a reduced state already on the hyperplane that is then converted into the <code>D</code> dimensional state.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DynamicalSystemsBase
ds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)
pmap = poincaremap(ds, (3, 0.0))
step!(pmap)
next_state_on_psos = current_state(pmap)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/poincare/poincaremap.jl#L12-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_crossing_time" href="#DynamicalSystemsBase.current_crossing_time"><code>DynamicalSystemsBase.current_crossing_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_crossing_time(pmap::PoincareMap) → tcross</code></pre><p>Return the time of the latest crossing of the Poincare section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/poincare/poincaremap.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.poincaresos" href="#DynamicalSystemsBase.poincaresos"><code>DynamicalSystemsBase.poincaresos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">poincaresos(A::AbstractStateSpaceSet, plane; kwargs...) → P::StateSpaceSet</code></pre><p>Calculate the Poincaré surface of section of the given dataset with the given <code>plane</code> by performing linear interpolation betweeen points that sandwich the hyperplane.</p><p>Argument <code>plane</code> and keywords <code>direction, warning, save_idxs</code> are the same as in <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/poincare/hyperplane.jl#L77-L85">source</a></section><section><div><pre><code class="language-julia hljs">poincaresos(ds::CoupledODEs, plane, T = 1000.0; kwargs...) → P::StateSpaceSet</code></pre><p>Return the iterations of <code>ds</code> on the Poincaré surface of section with the <code>plane</code>, by evolving <code>ds</code> up to a total of <code>T</code>. Return a <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a> of the points that are on the surface of section.</p><p>This function initializes a <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> and steps it until its <a href="#DynamicalSystemsBase.current_crossing_time"><code>current_crossing_time</code></a> exceeds <code>T</code>. You can also use <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> with <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> to get a sequence of <code>N::Int</code> points instead.</p><p>The keywords <code>Ttr, save_idxs</code> act as in <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a>. See <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> for <code>plane</code> and all other keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/poincare/poincaremap.jl#L246-L259">source</a></section></article><h2 id="TangentDynamicalSystem"><a class="docs-heading-anchor" href="#TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a><a id="TangentDynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#TangentDynamicalSystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.CoreDynamicalSystem" href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>DynamicalSystemsBase.CoreDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoreDynamicalSystem</code></pre><p>Union type meaning either <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>, which are the core systems whose dynamic rule <code>f</code> is known analytically.</p><p>This type is used for deciding whether a creation of a <a href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> is possible or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core_systems/additional_supertypes.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.TangentDynamicalSystem" href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>DynamicalSystemsBase.TangentDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TangentDynamicalSystem &lt;: DynamicalSystem
TangentDynamicalSystem(ds::CoreDynamicalSystem; kwargs...)</code></pre><p>A dynamical system that bundles the evolution of <code>ds</code> (which must be an <a href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>CoreDynamicalSystem</code></a>) and <code>k</code> deviation vectors that are evolved according to the <em>dynamics in the tangent space</em> (also called linearized dynamics or the tangent dynamics).</p><p>The state of <code>ds</code> <strong>must</strong> be an <code>AbstractVector</code> for <code>TangentDynamicalSystem</code>.</p><p><code>TangentDynamicalSystem</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li><code>reinit!</code> takes an additional keyword <code>Q0</code> (with same default as below)</li><li>The additional functions <a href="#DynamicalSystemsBase.current_deviations"><code>current_deviations</code></a> and <a href="#DynamicalSystemsBase.set_deviations!"><code>set_deviations!</code></a> are provided for the deviation vectors.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>k</code> or <code>Q0</code>: <code>Q0</code> represents the initial deviation vectors (each column = 1 vector). If <code>k::Int</code> is given, a matrix <code>Q0</code> is created with the first <code>k</code> columns of the identity matrix. Otherwise <code>Q0</code> can be given directly as a matrix. It must hold that <code>size(Q, 1) == dimension(ds)</code>. You can use <a href="#StateSpaceSets.orthonormal"><code>orthonormal</code></a> for random orthonormal vectors. By default <code>k = dimension(ds)</code> is used.</li><li><code>u0 = current_state(ds)</code>: Starting state.</li><li><code>J</code> and <code>J0</code>: See section &quot;Jacobian&quot; below.</li></ul><p><strong>Description</strong></p><p>Let <span>$u$</span> be the state of <code>ds</code>, and <span>$y$</span> a deviation (or perturbation) vector. These two are evolved in parallel according to</p><p class="math-container">\[\begin{array}{rcl}
\frac{d\vec{x}}{dt} &amp;=&amp; f(\vec{x}) \\
\frac{dY}{dt} &amp;=&amp; J_f(\vec{x}) \cdot Y
\end{array}
\quad \mathrm{or}\quad
\begin{array}{rcl}
\vec{x}_{n+1} &amp;=&amp; f(\vec{x}_n) \\
Y_{n+1} &amp;=&amp; J_f(\vec{x}_n) \cdot Y_n.
\end{array}\]</p><p>for continuous or discrete time respectively. Here <span>$f$</span> is the <a href="#DynamicalSystemsBase.dynamic_rule"><code>dynamic_rule</code></a><code>(ds)</code> and <span>$J_f$</span> is the Jacobian of <span>$f$</span>.</p><p><strong>Jacobian</strong></p><p>The keyword <code>J</code> provides the Jacobian function. It must be a Julia function in the same form as <code>f</code>, the <a href="#DynamicalSystemsBase.dynamic_rule"><code>dynamic_rule</code></a>. Specifically, <code>J(u, p, n) -&gt; M::SMatrix</code> for the out-of-place version or <code>J(M, u, p, n)</code> for the in-place version acting in-place on <code>M</code>. in both cases <code>M</code> is a matrix whose columns are the deviation vectors.</p><p>By default <code>J = nothing</code>.  In this case <code>J</code> is constructed automatically using the module <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff</code></a>, hence its limitations also apply here. Even though <code>ForwardDiff</code> is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so it is recommended. Additionally, automatic and in-place Jacobians cannot be time dependent.</p><p>The keyword <code>J0</code> allows you to pass an initialized Jacobian matrix <code>J0</code>. This is useful for large in-place systems where only a few components of the Jacobian change during the time evolution. <code>J0</code> can be a sparse or any other matrix type. If not given, a matrix of zeros is used. <code>J0</code> is ignored for out of place systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/tangent_space.jl#L15-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_deviations" href="#DynamicalSystemsBase.current_deviations"><code>DynamicalSystemsBase.current_deviations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_deviations(tands::TangentDynamicalSystem)</code></pre><p>Return the deviation vectors of <code>tands</code> as a matrix with each column a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/tangent_space.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.set_deviations!" href="#DynamicalSystemsBase.set_deviations!"><code>DynamicalSystemsBase.set_deviations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_deviations!(tands::TangentDynamicalSystem, Q)</code></pre><p>Set the deviation vectors of <code>tands</code> to be <code>Q</code>, a matrix with each column a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/tangent_space.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceSets.orthonormal" href="#StateSpaceSets.orthonormal"><code>StateSpaceSets.orthonormal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orthonormal([T,] D, k) -&gt; ws</code></pre><p>Return a matrix <code>ws</code> with <code>k</code> columns, each being an <code>D</code>-dimensional orthonormal vector.</p><p><code>T</code> is the return type and can be either <code>SMatrix</code> or <code>Matrix</code>. If not given, it is <code>SMatrix</code> if <code>D*k &lt; 100</code>, otherwise <code>Matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/v1.4.5/src/utils.jl#L24-L31">source</a></section></article><h2 id="ProjectedDynamicalSystem"><a class="docs-heading-anchor" href="#ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a><a id="ProjectedDynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#ProjectedDynamicalSystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.ProjectedDynamicalSystem" href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>DynamicalSystemsBase.ProjectedDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedDynamicalSystem &lt;: DynamicalSystem
ProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)</code></pre><p>A dynamical system that represents a projection of an existing <code>ds</code> on a (projected) space.</p><p>The <code>projection</code> defines the projected space. If <code>projection isa AbstractVector{Int}</code>, then the projected space is simply the variable indices that <code>projection</code> contains. Otherwise, <code>projection</code> can be an arbitrary function that given the state of the original system <code>ds</code>, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.</p><p><code>complete_state</code> produces the state for the original system from the projected state. <code>complete_state</code> can always be a function that given the projected state returns a state in the original space. However, if <code>projection isa AbstractVector{Int}</code>, then <code>complete_state</code> can also be a vector that contains the values of the <em>remaining</em> variables of the system, i.e., those <em>not</em> contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.</p><p>Notice that <code>ProjectedDynamicalSystem</code> does not require an invertible projection, <code>complete_state</code> is only used during <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a>. <code>ProjectedDynamicalSystem</code> is in fact a rather trivial wrapper of <code>ds</code> which steps it as normal in the original state space and only projects as a last step, e.g., during <a href="#DynamicalSystemsBase.current_state"><code>current_state</code></a>.</p><p><strong>Examples</strong></p><p>Case 1: project 5-dimensional system to its last two dimensions.</p><pre><code class="language-julia hljs">ds = Systems.lorenz96(5)
projection = [4, 5]
complete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions
prods = ProjectedDynamicalSystem(ds, projection, complete_state)
reinit!(prods, [0.2, 0.4])
step!(prods)
get_state(prods)</code></pre><p>Case 2: custom projection to general functions of state.</p><pre><code class="language-julia hljs">ds = Systems.lorenz96(5)
projection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)]
complete_state(y) = repeat([y[1]/5], 5)
prods = # same as in above example...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/projected_system.jl#L6-L49">source</a></section></article><h2 id="ParallelDynamicalSystem"><a class="docs-heading-anchor" href="#ParallelDynamicalSystem"><code>ParallelDynamicalSystem</code></a><a id="ParallelDynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#ParallelDynamicalSystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.ParallelDynamicalSystem" href="#DynamicalSystemsBase.ParallelDynamicalSystem"><code>DynamicalSystemsBase.ParallelDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParallelDynamicalSystem &lt;: DynamicalSystem
ParallelDynamicalSystem(ds::DynamicalSystem, states::Vector{&lt;:AbstractArray})</code></pre><p>A struct that evolves several <code>states</code> of a given dynamical system in parallel <strong>at exactly the same times</strong>. Useful when wanting to evolve several different trajectories of the same system while ensuring that they share parameters and time vector.</p><p>This struct follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li>The function <a href="#DynamicalSystemsBase.current_state"><code>current_state</code></a> is called as <code>current_state(pds, i::Int = 1)</code> which returns the <code>i</code>th state. Same for <a href="#DynamicalSystemsBase.initial_state"><code>initial_state</code></a>.</li><li>Similarly, <a href="#DynamicalSystemsBase.set_state!"><code>set_state!</code></a> obtains a third argument <code>i::Int = 1</code> to set the <code>i</code>-th state.</li><li><a href="#DynamicalSystemsBase.current_states"><code>current_states</code></a> and <a href="#DynamicalSystemsBase.initial_states"><code>initial_states</code></a> can be used to get all parallel states.</li><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> takes in a vector of states (like <code>states</code>) for <code>u</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/parallel_systems.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.initial_states" href="#DynamicalSystemsBase.initial_states"><code>DynamicalSystemsBase.initial_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_states(pds::ParallelDynamicalSystem)</code></pre><p>Return an iterator over the initial parallel states of <code>pds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/parallel_systems.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.current_states" href="#DynamicalSystemsBase.current_states"><code>DynamicalSystemsBase.current_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_states(pds::ParallelDynamicalSystem)</code></pre><p>Return an iterator over the parallel states of <code>pds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/derived_systems/parallel_systems.jl#L123-L127">source</a></section></article><h2 id="ArbitrarySteppable"><a class="docs-heading-anchor" href="#ArbitrarySteppable"><code>ArbitrarySteppable</code></a><a id="ArbitrarySteppable-1"></a><a class="docs-heading-anchor-permalink" href="#ArbitrarySteppable" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DynamicalSystemsBase.ArbitrarySteppable" href="#DynamicalSystemsBase.ArbitrarySteppable"><code>DynamicalSystemsBase.ArbitrarySteppable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArbitrarySteppable &lt;: DiscreteTimeDynamicalSystem
ArbitrarySteppable(
    model, step!, extract_state, extract_parameters, reset_model!;
    isdeterministic = true, set_state = reinit!,
)</code></pre><p>A dynamical system generated by an arbitrary &quot;model&quot; that can be stepped <em>in-place</em> with some function <code>step!(model)</code> for 1 step. The state of the model is extracted by the <code>extract_state(model) -&gt; u</code> function The parameters of the model are extracted by the <code>extract_parameters(model) -&gt; p</code> function. The system may be re-initialized, via <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a>, with the <code>reset_model!</code> user-provided function that must have the call signature</p><pre><code class="language-julia hljs">reset_model!(model, u, p)</code></pre><p>given a (potentially new) state <code>u</code> and parameter container <code>p</code>, both of which will default to the initial ones in the <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> call.</p><p><code>ArbitrarySteppable</code> exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. <code>ArbitrarySteppable</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li><a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a> is always 0, as time counts the steps the model has taken since creation or last <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> call.</li><li><a href="#DynamicalSystemsBase.set_state!"><code>set_state!</code></a> is the same as <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> by default. If not, the keyword argument <code>set_state</code> is a function <code>set_state(model, u)</code> that sets the state of the model to <code>u</code>.</li><li>The keyword <code>isdeterministic</code> should be set properly, as it decides whether downstream algorithms should error or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/2d2e44342bc07c5ef681e3da446905d6c314c57e/src/core_systems/arbitrary_steppable.jl#L3-L34">source</a></section></article><h2 id="Parallelization"><a class="docs-heading-anchor" href="#Parallelization">Parallelization</a><a id="Parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization" title="Permalink"></a></h2><p>Since <code>DynamicalSystem</code>s are mutable, one needs to copy them before parallelizing, to avoid having to deal with complicated race conditions etc. The simplest way is with <code>deepcopy</code>. Here is an example block that shows how to parallelize calling some expensive function (e.g., calculating the Lyapunov exponent) over a parameter range using <code>Threads</code>:</p><pre><code class="language-julia hljs">ds = DynamicalSystem(f, u, p) # some concrete implementation
parameters = 0:0.01:1
outputs = zeros(length(parameters))

# Since `DynamicalSystem`s are mutable, we need to copy to parallelize
systems = [deepcopy(ds) for _ in 1:Threads.nthreads()-1]
pushfirst!(systems, ds) # we can save 1 copy

Threads.@threads for i in eachindex(parameters)
    system = systems[Threads.threadid()]
    set_parameter!(system, 1, parameters[i])
    outputs[i] = expensive_function(system, args...)
end</code></pre><h2 id="Advanced-example"><a class="docs-heading-anchor" href="#Advanced-example">Advanced example</a><a id="Advanced-example-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-example" title="Permalink"></a></h2><p>This is an advanced example of making an in-place implementation of coupled <a href="https://en.wikipedia.org/wiki/Standard_map">standard maps</a>. It will utilize a handcoded Jacobian, a sparse matrix for the Jacobinan, a default initial Jacobian matrix, as well as function-like-objects as the dynamic rule.</p><p>Coupled standard maps is a deterministic iterated map that can have arbitrary number of equations of motion, since you can couple <code>N</code> standard maps which are 2D maps, like so:</p><p class="math-container">\[\theta_{i}&#39; = \theta_i + p_{i}&#39; \\
p_{i}&#39; = p_i + k_i\sin(\theta_i) - \Gamma \left[\sin(\theta_{i+1} - \theta_{i}) + \sin(\theta_{i-1} - \theta_{i}) \right]\]</p><p>To model this, we will make a dedicated <code>struct</code>, which is parameterized on the number of coupled maps:</p><pre><code class="language-julia hljs">using DynamicalSystemsBase

struct CoupledStandardMaps{N}
    idxs::SVector{N, Int}
    idxsm1::SVector{N, Int}
    idxsp1::SVector{N, Int}
end</code></pre><p>(what these fields are will become apparent later)</p><p>We initialize the struct with the amount of standard maps we want to couple, and we also define appropriate parameters:</p><pre><code class="language-julia hljs">M = 5  # couple number
u0 = 0.001rand(2M) #initial state
ks = 0.9ones(M) # nonlinearity parameters
Γ = 1.0 # coupling strength
p = (ks, Γ) # parameter container

# Create struct:
SV = SVector{M, Int}
idxs = SV(1:M...) # indexes of thetas
idxsm1 = SV(circshift(idxs, +1)...)  #indexes of thetas - 1
idxsp1 = SV(circshift(idxs, -1)...)  #indexes of thetas + 1
# So that:
# x[i] ≡ θᵢ
# x[[idxsp1[i]]] ≡ θᵢ+₁
# x[[idxsm1[i]]] ≡ θᵢ-₁
csm = CoupledStandardMaps{M}(idxs, idxsm1, idxsp1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.CoupledStandardMaps{5}([1, 2, 3, 4, 5], [5, 1, 2, 3, 4], [2, 3, 4, 5, 1])</code></pre><p>We will now use this struct to define a <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">function-like-object</a>, a Type that also acts as a function</p><pre><code class="language-julia hljs">function (f::CoupledStandardMaps{N})(xnew::AbstractVector, x, p, n) where {N}
    ks, Γ = p
    @inbounds for i in f.idxs

        xnew[i+N] = mod2pi(
            x[i+N] + ks[i]*sin(x[i]) -
            Γ*(sin(x[f.idxsp1[i]] - x[i]) + sin(x[f.idxsm1[i]] - x[i]))
        )

        xnew[i] = mod2pi(x[i] + xnew[i+N])
    end
    return nothing
end</code></pre><p>We will use <em>the same</em> <code>struct</code> to create a function for the Jacobian:</p><pre><code class="language-julia hljs">function (f::CoupledStandardMaps{M})(
    J::AbstractMatrix, x, p, n) where {M}

    ks, Γ = p
    # x[i] ≡ θᵢ
    # x[[idxsp1[i]]] ≡ θᵢ+₁
    # x[[idxsm1[i]]] ≡ θᵢ-₁
    @inbounds for i in f.idxs
        cosθ = cos(x[i])
        cosθp= cos(x[f.idxsp1[i]] - x[i])
        cosθm= cos(x[f.idxsm1[i]] - x[i])
        J[i+M, i] = ks[i]*cosθ + Γ*(cosθp + cosθm)
        J[i+M, f.idxsm1[i]] = - Γ*cosθm
        J[i+M, f.idxsp1[i]] = - Γ*cosθp
        J[i, i] = 1 + J[i+M, i]
        J[i, f.idxsm1[i]] = J[i+M, f.idxsm1[i]]
        J[i, f.idxsp1[i]] = J[i+M, f.idxsp1[i]]
    end
    return nothing
end</code></pre><p>This is possible because the system state is a <code>Vector</code> while the Jacobian is a <code>Matrix</code>, so multiple dispatch can differentiate between the two.</p><p>Notice in addition, that the Jacobian function accesses <em>only half the elements of the matrix</em>. This is intentional, and takes advantage of the fact that the other half is constant. We can leverage this further, by making the Jacobian a sparse matrix. Because the <code>DynamicalSystem</code> constructors allow us to give in a pre-initialized Jacobian matrix, we take advantage of that and create:</p><pre><code class="language-julia hljs">using SparseArrays
J = zeros(eltype(u0), 2M, 2M)
# Set ∂/∂p entries (they are eye(M,M))
# And they dont change they are constants
for i in idxs
    J[i, i+M] = 1
    J[i+M, i+M] = 1
end
sparseJ = sparse(J)

csm(sparseJ, u0, p, 0) # apply Jacobian to initial state
sparseJ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10×10 SparseArrays.SparseMatrixCSC{Float64, Int64} with 40 stored entries:
  3.9  -1.0    ⋅     ⋅   -1.0  1.0   ⋅    ⋅    ⋅    ⋅ 
 -1.0   3.9  -1.0    ⋅     ⋅    ⋅   1.0   ⋅    ⋅    ⋅ 
   ⋅   -1.0   3.9  -1.0    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ 
   ⋅     ⋅   -1.0   3.9  -1.0   ⋅    ⋅    ⋅   1.0   ⋅ 
 -1.0    ⋅     ⋅   -1.0   3.9   ⋅    ⋅    ⋅    ⋅   1.0
  2.9  -1.0    ⋅     ⋅   -1.0  1.0   ⋅    ⋅    ⋅    ⋅ 
 -1.0   2.9  -1.0    ⋅     ⋅    ⋅   1.0   ⋅    ⋅    ⋅ 
   ⋅   -1.0   2.9  -1.0    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ 
   ⋅     ⋅   -1.0   2.9  -1.0   ⋅    ⋅    ⋅   1.0   ⋅ 
 -1.0    ⋅     ⋅   -1.0   2.9   ⋅    ⋅    ⋅    ⋅   1.0</code></pre><p>Now we are ready to create our dynamical system</p><pre><code class="language-julia hljs">ds = DeterministicIteratedMap(csm, u0, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-dimensional DeterministicIteratedMap
 deterministic: true
 discrete time: true
 in-place:      true
 dynamic rule:  CoupledStandardMaps
 parameters:    ([0.9, 0.9, 0.9, 0.9, 0.9], 1.0)
 time:          0
 state:         [0.0008765603415306132, 0.0007852439812434446, 0.00012550010305457238, 0.00041581391498235086, 0.00013550057266997317, 0.0008417514814242893, 0.0007602255362594905, 0.0007359071546520249, 0.0005674915643286803, 0.00044538163099324725]
</code></pre><p>Of course, the reason we went through all this trouble was to make a <a href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a>, that can actually use the Jacobian function.</p><pre><code class="language-julia hljs">tands = TangentDynamicalSystem(ds; J = csm, J0 = sparseJ, k = M)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-dimensional TangentDynamicalSystem
 deterministic:     true
 discrete time:     true
 in-place:          true
 dynamic rule:      CoupledStandardMaps
 jacobian:          CoupledStandardMaps
 deviation vectors: 5
 parameters:        ([0.9, 0.9, 0.9, 0.9, 0.9], 1.0)
 time:              0
 state:             [0.0008765603415306132, 0.0007852439812434446, 0.00012550010305457238, 0.00041581391498235086, 0.00013550057266997317, 0.0008417514814242893, 0.0007602255362594905, 0.0007359071546520249, 0.0005674915643286803, 0.00044538163099324725]
</code></pre><pre><code class="language-julia hljs">step!(tands, 5)
current_deviations(tands)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10×5 view(::Matrix{Float64}, :, 2:6) with eltype Float64:
  3679.74   -2646.24     839.629    725.461  -2529.93
 -2721.6     3827.61   -2671.84     793.348    841.94
   790.878  -2552.55    3591.41   -2491.7      730.62
   698.323    729.352  -2394.71    3398.43   -2363.3
 -2381.12     723.467    697.673  -2355.34    3383.24
  3024.8    -2220.92     727.909    614.225  -2105.25
 -2295.97    3171.97   -2246.5      681.838    730.211
   679.368  -2127.56    2936.6    -2066.89     619.244
   587.066    617.98   -1970.18    2744.24   -1938.91
 -1956.9      612.227    586.414  -1931.08    2729.37</code></pre><p>(the deviation vectors will increase in magnitude rapidly because the dynamical system is chaotic)</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DatserisParlitz2022"><a class="tag is-link" href="#citeref-DatserisParlitz2022">DatserisParlitz2022</a>Datseris &amp; Parlitz 2022, <em>Nonlinear Dynamics: A Concise Introduction Interlaced with Code</em>, <a href="https://doi.org/10.1007/978-3-030-91032-7">Springer Nature, Undergrad. Lect. Notes In Physics</a></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 6 February 2024 10:19">Tuesday 6 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
