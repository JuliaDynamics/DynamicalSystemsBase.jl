var documenterSearchIndex = {"docs":
[{"location":"#DynamicalSystemsBase.jl","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"DynamicalSystemsBase","category":"page"},{"location":"#DynamicalSystemsBase","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase","text":"DynamicalSystemsBase.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that defines the DynamicalSystem interface and many concrete implementations used in the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystemsBase\"). Typically, you do not want to use DynamicalSystemsBase directly, as downstream analysis packages re-export it.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"!!! note \"Tutorial and examples at DynamicalSystems.jl docs!     Please visit the documentation of the main DynamicalSystems.jl docs for a tutorial and examples on using the interface.","category":"page"},{"location":"#The-DynamicalSystem-API","page":"DynamicalSystemsBase.jl","title":"The DynamicalSystem API","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"DynamicalSystem","category":"page"},{"location":"#DynamicalSystemsBase.DynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.DynamicalSystem","text":"DynamicalSystem\n\nDynamicalSystem is an abstract supertype encompassing all concrete implementations of what counts as a \"dynamical system\" in the DynamicalSystems.jl library.\n\nAll concrete implementations of DynamicalSystem can be iteratively evolved in time via the step! function. Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has for parallelization.\n\nDynamicalSystem is further separated into two abstract types: ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem. The simplest and most common concrete implementations of a DynamicalSystem are DeterministicIteratedMap or CoupledODEs.\n\nDescription\n\nA DynamicalSystem represents the time evolution of a state in a state space. It mainly encapsulates three things:\n\nA state, typically referred to as u, with initial value u0. The space that u occupies is the state space of ds and the length of u is the dimension of ds (and of the state space).\nA dynamic rule, typically referred to as f, that dictates how the state evolves/changes with time when calling the step! function. f is typically a standard Julia function, see the online documentation for examples.\nA parameter container p that parameterizes f. p can be anything, but in general it is recommended to be a type-stable mutable container.\n\nIn sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of DynamicalSystem are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.\n\nIn this scope dynamical systems have a known dynamic rule f. Finite measured or sampled data from a dynamical system are represented using StateSpaceSet. Such data are obtained from the trajectory function or from an experimental measurement of a dynamical system with an unknown dynamic rule.\n\nSee also the DynamicalSystems.jl tutorial online for examples making dynamical systems.\n\nIntegration with ModelingToolkit.jl\n\nDynamical systems that have been constructed from DEProblems that themselves have been constructed from ModelingToolkit.jl keep a reference to the symbolic model and all symbolic variables. Accessing a DynamicalSystem using symbolic variables is possible via the functions observe_state, set_state!, current_parameter and set_parameter!. The referenced MTK model corresponding to the dynamical system can be obtained with model = referrenced_sciml_model(ds::DynamicalSystem).\n\nSee also the DynamicalSystems.jl tutorial online for an example.\n\nwarn: ModelingToolkit.jl v9\nIn ModelingToolkit.jl v9 the default split behavior of the parameter container is true. This means that the parameter container is no longer a Vector{Float64} by default, which means that you cannot use integers to access parameters. It is recommended to keep split = true (default) and only access parameters via their symbolic parameter binding. Use structural_simplify(sys; split = false) to allow accessing parameters with integers again.\n\nAPI\n\nThe API that DynamicalSystem employs is composed of the functions listed below. Once a concrete instance of a subtype of DynamicalSystem is obtained, it can queried or altered with the following functions.\n\nThe main use of a concrete dynamical system instance is to provide it to downstream functions such as lyapunovspectrum from ChaosTools.jl or basins_of_attraction from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.\n\nAPI - obtain information\n\nds(t) with ds an instance of DynamicalSystem: return the state of ds at time t. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if t is the current time.\ncurrent_state\ninitial_state\nobserve_state\ncurrent_parameters\ncurrent_parameter\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace\nsuccessful_step\nreferrenced_sciml_model\n\nAPI - alter status\n\nreinit!\nset_state!\nset_parameter!\nset_parameters!\n\n\n\n\n\n","category":"type"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"current_state\ninitial_state\nobserve_state\nstate_name\ncurrent_parameters\ncurrent_parameter\nparameter_name\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace(::DynamicalSystem)\nsuccessful_step\nreferrenced_sciml_model","category":"page"},{"location":"#DynamicalSystemsBase.current_state","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_state","text":"current_state(ds::DynamicalSystem) → u::AbstractArray\n\nReturn the current state of ds. This state is mutated when ds is mutated. See also initial_state, observe_state.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.initial_state","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_state","text":"initial_state(ds::DynamicalSystem) → u0\n\nReturn the initial state of ds. This state is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.observe_state","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.observe_state","text":"observe_state(ds::DynamicalSystem, i, u = current_state(ds)) → x::Real\n\nReturn the state u of ds observed at \"index\" i. Possibilities are:\n\ni::Int returns the i-th dynamic variable.\ni::Function returns f(current_state(ds)).\ni::SymbolLike returns the value of the corresponding symbolic variable.  This is valid only for dynamical systems referrencing a ModelingToolkit.jl model  which also has i as one of its listed variables (either uknowns or observed).  Here i can be anything can be anything  that could index the solution object sol = ModelingToolkit.solve(...),  such as a Num or Symbol instance with the name of the symbolic variable.  In this case, a last fourth optional positional argument t defaults to  current_time(ds) and is the time to observe the state at.\n\nFor ProjectedDynamicalSystem, this function assumes that the state of the system is the full state space state, not the projected one (this makes the most sense for allowing MTK-based indexing).\n\nUse state_name for an accompanying name.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.state_name","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.state_name","text":"state_name(index)::String\n\nReturn a name that matches the outcome of observe_state with index.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_parameters","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_parameters","text":"current_parameters(ds::DynamicalSystem) → p\n\nReturn the current parameter container of ds. This is mutated in functions that need to evolve ds across a parameter range.\n\nSee also initial_parameters, current_parameter, set_parameter!.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_parameter","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_parameter","text":"current_parameter(ds::DynamicalSystem, index [,p])\n\nReturn the specific parameter of ds corresponding to index, which can be anything given to set_parameter!. p defaults to current_parameters and is the parameter container to extract the parameter from, which must match layout with its default value.\n\nUse parameter_name for an accompanying name.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.parameter_name","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.parameter_name","text":"parameter_name(index)::String\n\nReturn a name that matches the outcome of current_parameter with index.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.initial_parameters","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_parameters","text":"initial_parameters(ds::DynamicalSystem) → p0\n\nReturn the initial parameter container of ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.isdeterministic","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.isdeterministic","text":"isdeterministic(ds::DynamicalSystem) → true/false\n\nReturn true if ds is deterministic, i.e., the dynamic rule contains no randomness. This is information deduced from the type of ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.isdiscretetime","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.isdiscretetime","text":"isdiscretetime(ds::DynamicalSystem) → true/false\n\nReturn true if ds operates in discrete time, or false if it is in continuous time. This is information deduced from the type of ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.dynamic_rule","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.dynamic_rule","text":"dynamic_rule(ds::DynamicalSystem) → f\n\nReturn the dynamic rule of ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_time","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_time","text":"current_time(ds::DynamicalSystem) → t\n\nReturn the current time that ds is at. This is mutated when ds is evolved.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.initial_time","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_time","text":"initial_time(ds::DynamicalSystem) → t0\n\nReturn the initial time defined for ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#SciMLBase.isinplace-Tuple{DynamicalSystem}","page":"DynamicalSystemsBase.jl","title":"SciMLBase.isinplace","text":"isinplace(ds::DynamicalSystem) → true/false\n\nReturn true if the dynamic rule of ds is in-place, i.e., a function mutating the state in place. If true, the state is typically Array, if false, the state is typically SVector. A front-end user will most likely not care about this information, but a developer may care.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicalSystemsBase.successful_step","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.successful_step","text":"successful_step(ds::DynamicalSystem) -> true/false\n\nReturn true if the last step! call to ds was successful, false otherwise. For continuous time systems this uses DifferentialEquations.jl error checking, for discrete time it checks if any variable is Inf or NaN.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.referrenced_sciml_model","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.referrenced_sciml_model","text":"referrenced_sciml_model(ds::DynamicalSystem)\n\nReturn the ModelingToolkit.jl structurally-simplified model referrenced by ds. Return nothing if there is no referrenced model.\n\n\n\n\n\n","category":"function"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"reinit!(::DynamicalSystem, ::AbstractDict; kwargs...)\nset_state!\nset_parameter!\nset_parameters!","category":"page"},{"location":"#SciMLBase.reinit!-Tuple{DynamicalSystem, AbstractDict}","page":"DynamicalSystemsBase.jl","title":"SciMLBase.reinit!","text":"reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds\n\nReset the status of ds, so that it is as if it has be just initialized with initial state u. Practically every function of the ecosystem that evolves ds first calls this function on it. Besides the new state u, you can also configure the keywords t0 = initial_time(ds) and p = current_parameters(ds).\n\nreinit!(ds::DynamicalSystem, u::AbstractDict; kwargs...) → ds\n\nIf u is a AbstractDict (for partially setting specific state variables in set_state!), then the alterations are done in the state given by the keyword reference_state = copy(initial_state(ds)).\n\nreinit!(ds, ::Nothing; kwargs...)\n\nThis method does nothing and leaves the system as is. This is so that downstream functions that call reinit! can still be used without resetting the system but rather continuing from its exact current state.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicalSystemsBase.set_state!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_state!","text":"set_state!(ds::DynamicalSystem, u::AbstractArray{Real})\n\nSet the state of ds to u, which must match dimensionality with that of ds. Also ensure that the change is notified to whatever integration protocol is used.\n\n\n\n\n\nset_state!(ds::DynamicalSystem, value::Real, i) → u\n\nSet the ith variable of ds to value. The index i can be an integer or a symbolic-like index for systems that reference a ModelingToolkit.jl model. For example:\n\ni = :x # or `1` or `only(@variables(x))`\nset_state!(ds, 0.5, i)\n\nWarning: this function should not be used with derivative dynamical systems such as Poincare/stroboscopic/projected dynamical systems. Use the method below to manipulate an array and give that to set_state!.\n\nset_state!(u::AbstractArray, value, index, ds::DynamicalSystem)\n\nModify the given state u and leave ds untouched.\n\n\n\n\n\nset_state!(ds::DynamicalSystem, mapping::AbstractDict)\n\nConvenience version of set_state! that iteratively calls set_state!(ds, val, i) for all index-value pairs (i, val) in mapping. This allows you to partially set only some state variables.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.set_parameter!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_parameter!","text":"set_parameter!(ds::DynamicalSystem, index, value [, p])\n\nChange a parameter of ds given the index it has in the parameter container and the value to set it to. This function works for any type of parameter container (array/dictionary/composite types) provided the index is appropriate type.\n\nThe index can be a traditional Julia index (integer for arrays, key for dictionaries, or symbol for composite types). It can also be a symbolic variable or Symbol instance. This is valid only for dynamical systems referring a ModelingToolkit.jl model which also has index as one of its parameters.\n\nThe last optional argument p defaults to current_parameters and is the parameter container whose value is changed at the given index. It must match layout with its default value.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.set_parameters!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_parameters!","text":"set_parameters!(ds::DynamicalSystem, p = initial_parameters(ds))\n\nSet the parameter values in the current_parameters(ds) to match those in p. This is done as an in-place overwrite by looping over the keys of p hence p can be an arbitrary container mapping parameter indices to values (such as a Vector{Real}, Vector{Pair}, or AbstractDict).\n\nThe keys of p must be valid keys that can be given to set_parameter!.\n\n\n\n\n\n","category":"function"},{"location":"#Time-evolution","page":"DynamicalSystemsBase.jl","title":"Time evolution","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"step!(::DynamicalSystem, args...; kwargs...)\ntrajectory\nStateSpaceSet","category":"page"},{"location":"#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}","page":"DynamicalSystemsBase.jl","title":"CommonSolve.step!","text":"step!(ds::DiscreteTimeDynamicalSystem [, n::Integer]) → ds\n\nEvolve the discrete time dynamical system for 1 or n steps.\n\nstep!(ds::ContinuousTimeDynamicalSystem, [, dt::Real [, stop_at_tdt]]) → ds\n\nEvolve the continuous time dynamical system for one integration step.\n\nAlternatively, if a dt is given, then progress the integration until there is a temporal difference ≥ dt (so, step at least for dt time).\n\nWhen true is passed to the optional third argument, the integration advances for exactly dt time.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicalSystemsBase.trajectory","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.trajectory","text":"trajectory(ds::DynamicalSystem, T [, u0]; kwargs...) → X, t\n\nEvolve ds for a total time of T and return its trajectory X, sampled at equal time intervals, and corresponding time vector. Optionally provide a starting state u0 which is current_state(ds) by default.\n\nThe returned time vector is t = (t0+Ttr):Δt:(t0+Ttr+T).\n\nIf time evolution diverged before T, the remaining of the trajectory is set to the last valid point.\n\ntrajectory is a very simple function provided for convenience. For continuous time systems, it doesn't play well with callbacks, use DifferentialEquations.solve if you want a trajectory/timeseries that works with callbacks.\n\nKeyword arguments\n\nΔt:  Time step of value output. For discrete time systems it must be an integer. Defaults to 0.1 for continuous and 1 for discrete time systems. If you don't have access to unicode, the keyword Dt can be used instead.\nTtr = 0: Transient time to evolve the initial state before starting saving states.\nt0 = initial_time(ds): Starting time.\nsave_idxs::AbstractVector: Which variables to output in X. It can be any type of index that can be given to observe_state. Defaults to 1:dimension(ds) (all dynamic variables). Note: if you mix integer and symbolic indexing be sure to initialize the array as Any so that integers 1, 2, ... are not converted to symbolic expressions.\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.StateSpaceSet","page":"DynamicalSystemsBase.jl","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"#DeterministicIteratedMap","page":"DynamicalSystemsBase.jl","title":"DeterministicIteratedMap","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"DeterministicIteratedMap","category":"page"},{"location":"#DynamicalSystemsBase.DeterministicIteratedMap","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.DeterministicIteratedMap","text":"DeterministicIteratedMap <: DynamicalSystem\nDeterministicIteratedMap(f, u0, p = nothing; t0 = 0)\n\nA deterministic discrete time dynamical system defined by an iterated map as follows:\n\nvecu_n+1 = vecf(vecu_n p n)\n\nAn alias for DeterministicIteratedMap is DiscreteDynamicalSystem.\n\nOptionally configure the parameter container p and initial time t0.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\n\n\n\n\n","category":"type"},{"location":"#CoupledODEs","page":"DynamicalSystemsBase.jl","title":"CoupledODEs","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"CoupledODEs","category":"page"},{"location":"#DynamicalSystemsBase.CoupledODEs","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\nDifferentialEquations.jl interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = Tsit5(; stagelimiter! = triviallimiter!, steplimiter! = triviallimiter!, thread = static(false),), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling .\n\nThe convenience constructors CoupledODEs(prob::ODEProblem [, diffeq]) and CoupledODEs(ds::CoupledODEs [, diffeq]) are also available. To integrate with ModelingToolkit.jl, the dynamical system must be created via the ODEProblem (which itself is created via ModelingToolkit.jl), see the Tutorial for an example.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the ODEProblem is integ.sol.prob. The convenience syntax ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) is available to extract the problem.\n\n\n\n\n\n","category":"type"},{"location":"#StroboscopicMap","page":"DynamicalSystemsBase.jl","title":"StroboscopicMap","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"StroboscopicMap","category":"page"},{"location":"#DynamicalSystemsBase.StroboscopicMap","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.StroboscopicMap","text":"StroboscopicMap <: DiscreteTimeDynamicalSystem\nStroboscopicMap(ds::CoupledODEs, period::Real) → smap\nStroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)\n\nA discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) CoupledODEs system exactly over a given period. The second signature first creates a CoupledODEs and then calls the first.\n\nStroboscopicMap follows the DynamicalSystem interface. In addition, the function set_period!(smap, period) is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, current_time and initial_time are integers. The initial time is always 0, because current_time counts elapsed periods. Call these functions on the parent of StroboscopicMap to obtain the corresponding continuous time. In contrast, reinit! expects t0 in continuous time.\n\nThe convenience constructor\n\nStroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap\n\nis also provided.\n\nSee also PoincareMap.\n\n\n\n\n\n","category":"type"},{"location":"#PoincareMap","page":"DynamicalSystemsBase.jl","title":"PoincareMap","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"PoincareMap\ncurrent_crossing_time\npoincaresos","category":"page"},{"location":"#DynamicalSystemsBase.PoincareMap","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.PoincareMap","text":"PoincareMap <: DiscreteTimeDynamicalSystem\nPoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap\n\nA discrete time dynamical system that produces iterations over the Poincaré map[DatserisParlitz2022] of the given continuous time ds. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the plane argument.\n\nSee also StroboscopicMap, poincaresos.\n\nKeyword arguments\n\ndirection = -1: Only crossings with sign(direction) are considered to belong to the surface of section. Negative direction means going from less than b to greater than b.\nu0 = nothing: Specify an initial state.\nrootkw = (xrtol = 1e-6, atol = 1e-8): A NamedTuple of keyword arguments passed to find_zero from Roots.jl.\nTmax = 1e3: The argument Tmax exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one step! the system has been evolved for more than Tmax, then step!(pmap) will terminate and error.\n\nDescription\n\nThe Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. PoincareMap iterates over the crossings of the section.\n\nIf the state of ds is mathbfu = (u_1 ldots u_D) then the equation defining a hyperplane is\n\na_1u_1 + dots + a_Du_D = mathbfacdotmathbfu=b\n\nwhere mathbfa b are the parameters of the hyperplane.\n\nIn code, plane can be either:\n\nA Tuple{Int, <: Real}, like (j, r): the plane is defined as when the jth variable of the system equals the value r.\nA vector of length D+1. The first D elements of the vector correspond to mathbfa while the last element is b.\n\nPoincareMap uses ds, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.\n\nPoincareMap follows the DynamicalSystem interface with the following adjustments:\n\ndimension(pmap) == dimension(ds), even though the Poincaré map is effectively 1 dimension less.\nLike StroboscopicMap time is discrete and counts the iterations on the surface of section. initial_time is always 0 and current_time is current iteration number.\nA new function current_crossing_time returns the real time corresponding to the latest crossing of the hyperplane, which is what the current_state(ds) corresponds to as well.\nFor the special case of plane being a Tuple{Int, <:Real}, a special reinit! method is allowed with input state of length D-1 instead of D, i.e., a reduced state already on the hyperplane that is then converted into the D dimensional state.\n\nExample\n\nusing DynamicalSystemsBase\nds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)\npmap = poincaremap(ds, (3, 0.0))\nstep!(pmap)\nnext_state_on_psos = current_state(pmap)\n\n[DatserisParlitz2022]: Datseris & Parlitz 2022, Nonlinear Dynamics: A Concise Introduction Interlaced with Code, Springer Nature, Undergrad. Lect. Notes In Physics\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.current_crossing_time","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_crossing_time","text":"current_crossing_time(pmap::PoincareMap) → tcross\n\nReturn the time of the latest crossing of the Poincare section.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.poincaresos","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.poincaresos","text":"poincaresos(A::AbstractStateSpaceSet, plane; kwargs...) → P::StateSpaceSet\n\nCalculate the Poincaré surface of section of the given dataset with the given plane by performing linear interpolation betweeen points that sandwich the hyperplane.\n\nArgument plane and keywords direction, warning, save_idxs are the same as in PoincareMap.\n\n\n\n\n\npoincaresos(ds::CoupledODEs, plane, T = 1000.0; kwargs...) → P::StateSpaceSet\n\nReturn the iterations of ds on the Poincaré surface of section with the plane, by evolving ds up to a total of T. Return a StateSpaceSet of the points that are on the surface of section.\n\nThis function initializes a PoincareMap and steps it until its current_crossing_time exceeds T. You can also use trajectory with PoincareMap to get a sequence of N::Int points instead.\n\nThe keywords Ttr, save_idxs act as in trajectory. See PoincareMap for plane and all other keywords.\n\n\n\n\n\n","category":"function"},{"location":"#TangentDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"TangentDynamicalSystem","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"CoreDynamicalSystem\nTangentDynamicalSystem\ncurrent_deviations\nset_deviations!\northonormal","category":"page"},{"location":"#DynamicalSystemsBase.CoreDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.CoreDynamicalSystem","text":"CoreDynamicalSystem\n\nUnion type meaning either DeterministicIteratedMap or CoupledODEs, which are the core systems whose dynamic rule f is known analytically.\n\nThis type is used for deciding whether a creation of a TangentDynamicalSystem is possible or not.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.TangentDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.TangentDynamicalSystem","text":"TangentDynamicalSystem <: DynamicalSystem\nTangentDynamicalSystem(ds::CoreDynamicalSystem; kwargs...)\n\nA dynamical system that bundles the evolution of ds (which must be an CoreDynamicalSystem) and k deviation vectors that are evolved according to the dynamics in the tangent space (also called linearized dynamics or the tangent dynamics).\n\nThe state of ds must be an AbstractVector for TangentDynamicalSystem.\n\nTangentDynamicalSystem follows the DynamicalSystem interface with the following adjustments:\n\nreinit! takes an additional keyword Q0 (with same default as below)\nThe additional functions current_deviations and set_deviations! are provided for the deviation vectors.\n\nKeyword arguments\n\nk or Q0: Q0 represents the initial deviation vectors (each column = 1 vector). If k::Int is given, a matrix Q0 is created with the first k columns of the identity matrix. Otherwise Q0 can be given directly as a matrix. It must hold that size(Q, 1) == dimension(ds). You can use orthonormal for random orthonormal vectors. By default k = dimension(ds) is used.\nu0 = current_state(ds): Starting state.\nJ and J0: See section \"Jacobian\" below.\n\nDescription\n\nLet u be the state of ds, and y a deviation (or perturbation) vector. These two are evolved in parallel according to\n\nbeginarrayrcl\nfracdvecxdt = f(vecx) \nfracdYdt = J_f(vecx) cdot Y\nendarray\nquad mathrmorquad\nbeginarrayrcl\nvecx_n+1 = f(vecx_n) \nY_n+1 = J_f(vecx_n) cdot Y_n\nendarray\n\nfor continuous or discrete time respectively. Here f is the dynamic_rule(ds) and J_f is the Jacobian of f.\n\nJacobian\n\nThe keyword J provides the Jacobian function. It must be a Julia function in the same form as f, the dynamic_rule. Specifically, J(u, p, n) -> M::SMatrix for the out-of-place version or J(M, u, p, n) for the in-place version acting in-place on M. In both cases M is the Jacobian matrix used for the evolution of the deviation vectors.\n\nBy default J = nothing.  In this case J is constructed automatically using the module ForwardDiff, hence its limitations also apply here. Even though ForwardDiff is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so it is recommended. Additionally, automatic and in-place Jacobians cannot be time dependent.\n\nThe keyword J0 allows you to pass an initialized Jacobian matrix J0. This is useful for large in-place systems where only a few components of the Jacobian change during the time evolution. J0 can be a sparse or any other matrix type. If not given, a matrix of zeros is used. J0 is ignored for out of place systems.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.current_deviations","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_deviations","text":"current_deviations(tands::TangentDynamicalSystem)\n\nReturn the deviation vectors of tands as a matrix with each column a vector.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.set_deviations!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_deviations!","text":"set_deviations!(tands::TangentDynamicalSystem, Q)\n\nSet the deviation vectors of tands to be Q, a matrix with each column a vector.\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.orthonormal","page":"DynamicalSystemsBase.jl","title":"StateSpaceSets.orthonormal","text":"orthonormal([T,] D, k) -> ws\n\nReturn a matrix ws with k columns, each being an D-dimensional orthonormal vector.\n\nT is the return type and can be either SMatrix or Matrix. If not given, it is SMatrix if D*k < 100, otherwise Matrix.\n\n\n\n\n\n","category":"function"},{"location":"#ProjectedDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"ProjectedDynamicalSystem","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ProjectedDynamicalSystem","category":"page"},{"location":"#DynamicalSystemsBase.ProjectedDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.ProjectedDynamicalSystem","text":"ProjectedDynamicalSystem <: DynamicalSystem\nProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)\n\nA dynamical system that represents a projection of an existing ds on a (projected) space.\n\nThe projection defines the projected space. If projection isa AbstractVector{Int}, then the projected space is simply the variable indices that projection contains. Otherwise, projection can be an arbitrary function that given the state of the original system ds, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.\n\ncomplete_state produces the state for the original system from the projected state. complete_state can always be a function that given the projected state returns a state in the original space. However, if projection isa AbstractVector{Int}, then complete_state can also be a vector that contains the values of the remaining variables of the system, i.e., those not contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.\n\nNotice that ProjectedDynamicalSystem does not require an invertible projection, complete_state is only used during reinit!. ProjectedDynamicalSystem is in fact a rather trivial wrapper of ds which steps it as normal in the original state space and only projects as a last step, e.g., during current_state.\n\nExamples\n\nCase 1: project 5-dimensional system to its last two dimensions.\n\nds = Systems.lorenz96(5)\nprojection = [4, 5]\ncomplete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions\nprods = ProjectedDynamicalSystem(ds, projection, complete_state)\nreinit!(prods, [0.2, 0.4])\nstep!(prods)\nget_state(prods)\n\nCase 2: custom projection to general functions of state.\n\nds = Systems.lorenz96(5)\nprojection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)]\ncomplete_state(y) = repeat([y[1]/5], 5)\nprods = # same as in above example...\n\n\n\n\n\n","category":"type"},{"location":"#ParallelDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"ParallelDynamicalSystem","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ParallelDynamicalSystem\ninitial_states\ncurrent_states","category":"page"},{"location":"#DynamicalSystemsBase.ParallelDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.ParallelDynamicalSystem","text":"ParallelDynamicalSystem <: DynamicalSystem\nParallelDynamicalSystem(ds::DynamicalSystem, states::Vector{<:AbstractArray})\n\nA struct that evolves several states of a given dynamical system in parallel at exactly the same times. Useful when wanting to evolve several different trajectories of the same system while ensuring that they share parameters and time vector.\n\nThis struct follows the DynamicalSystem interface with the following adjustments:\n\nThe function current_state is called as current_state(pds, i::Int = 1) which returns the ith state. Same for initial_state.\nSimilarly, set_state! obtains a third argument i::Int = 1 to set the i-th state.\ncurrent_states and initial_states can be used to get all parallel states.\nreinit! takes in a vector of states (like states) for u.\n\nParallelDynamicalSystem(ds::DynamicalSystem, states::Vector{<:Dict})\n\nFor a dynamical system referring a MTK model, one can specify states as a vector of dictionaries to alter the current state of ds as in set_state!.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.initial_states","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_states","text":"initial_states(pds::ParallelDynamicalSystem)\n\nReturn an iterator over the initial parallel states of pds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_states","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_states","text":"current_states(pds::ParallelDynamicalSystem)\n\nReturn an iterator over the parallel states of pds.\n\n\n\n\n\n","category":"function"},{"location":"#ArbitrarySteppable","page":"DynamicalSystemsBase.jl","title":"ArbitrarySteppable","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ArbitrarySteppable","category":"page"},{"location":"#DynamicalSystemsBase.ArbitrarySteppable","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.ArbitrarySteppable","text":"ArbitrarySteppable <: DiscreteTimeDynamicalSystem\nArbitrarySteppable(\n    model, step!, extract_state, extract_parameters, reset_model!;\n    isdeterministic = true, set_state = reinit!,\n)\n\nA dynamical system generated by an arbitrary \"model\" that can be stepped in-place with some function step!(model) for 1 step. The state of the model is extracted by the extract_state(model) -> u function The parameters of the model are extracted by the extract_parameters(model) -> p function. The system may be re-initialized, via reinit!, with the reset_model! user-provided function that must have the call signature\n\nreset_model!(model, u, p)\n\ngiven a (potentially new) state u and parameter container p, both of which will default to the initial ones in the reinit! call.\n\nArbitrarySteppable exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. ArbitrarySteppable follows the DynamicalSystem interface with the following adjustments:\n\ninitial_time is always 0, as time counts the steps the model has taken since creation or last reinit! call.\nset_state! is the same as reinit! by default. If not, the keyword argument set_state is a function set_state(model, u) that sets the state of the model to u.\nThe keyword isdeterministic should be set properly, as it decides whether downstream algorithms should error or not.\n\n\n\n\n\n","category":"type"},{"location":"#Parallelization","page":"DynamicalSystemsBase.jl","title":"Parallelization","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Since DynamicalSystems are mutable, one needs to copy them before parallelizing, to avoid having to deal with complicated race conditions etc. The simplest way is with deepcopy. Here is an example block that shows how to parallelize calling some expensive function (e.g., calculating the Lyapunov exponent) over a parameter range using Threads:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ds = DynamicalSystem(f, u, p) # some concrete implementation\nparameters = 0:0.01:1\noutputs = zeros(length(parameters))\n\n# Since `DynamicalSystem`s are mutable, we need to copy to parallelize\nsystems = [deepcopy(ds) for _ in 1:Threads.nthreads()-1]\npushfirst!(systems, ds) # we can save 1 copy\n\nThreads.@threads for i in eachindex(parameters)\n    system = systems[Threads.threadid()]\n    set_parameter!(system, 1, parameters[i])\n    outputs[i] = expensive_function(system, args...)\nend","category":"page"},{"location":"#Advanced-example","page":"DynamicalSystemsBase.jl","title":"Advanced example","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"This is an advanced example of making an in-place implementation of coupled standard maps. It will utilize a handcoded Jacobian, a sparse matrix for the Jacobinan, a default initial Jacobian matrix, as well as function-like-objects as the dynamic rule.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Coupled standard maps is a deterministic iterated map that can have arbitrary number of equations of motion, since you can couple N standard maps which are 2D maps, like so:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"theta_i = theta_i + p_i \np_i = p_i + k_isin(theta_i) - Gamma leftsin(theta_i+1 - theta_i) + sin(theta_i-1 - theta_i) right","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"To model this, we will make a dedicated struct, which is parameterized on the number of coupled maps:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"using DynamicalSystemsBase\n\nstruct CoupledStandardMaps{N}\n    idxs::SVector{N, Int}\n    idxsm1::SVector{N, Int}\n    idxsp1::SVector{N, Int}\nend","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"(what these fields are will become apparent later)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"We initialize the struct with the amount of standard maps we want to couple, and we also define appropriate parameters:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"M = 5  # couple number\nu0 = 0.001rand(2M) #initial state\nks = 0.9ones(M) # nonlinearity parameters\nΓ = 1.0 # coupling strength\np = (ks, Γ) # parameter container\n\n# Create struct:\nSV = SVector{M, Int}\nidxs = SV(1:M...) # indexes of thetas\nidxsm1 = SV(circshift(idxs, +1)...)  #indexes of thetas - 1\nidxsp1 = SV(circshift(idxs, -1)...)  #indexes of thetas + 1\n# So that:\n# x[i] ≡ θᵢ\n# x[[idxsp1[i]]] ≡ θᵢ+₁\n# x[[idxsm1[i]]] ≡ θᵢ-₁\ncsm = CoupledStandardMaps{M}(idxs, idxsm1, idxsp1)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"We will now use this struct to define a function-like-object, a Type that also acts as a function","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"function (f::CoupledStandardMaps{N})(xnew::AbstractVector, x, p, n) where {N}\n    ks, Γ = p\n    @inbounds for i in f.idxs\n\n        xnew[i+N] = mod2pi(\n            x[i+N] + ks[i]*sin(x[i]) -\n            Γ*(sin(x[f.idxsp1[i]] - x[i]) + sin(x[f.idxsm1[i]] - x[i]))\n        )\n\n        xnew[i] = mod2pi(x[i] + xnew[i+N])\n    end\n    return nothing\nend","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"We will use the same struct to create a function for the Jacobian:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"function (f::CoupledStandardMaps{M})(\n    J::AbstractMatrix, x, p, n) where {M}\n\n    ks, Γ = p\n    # x[i] ≡ θᵢ\n    # x[[idxsp1[i]]] ≡ θᵢ+₁\n    # x[[idxsm1[i]]] ≡ θᵢ-₁\n    @inbounds for i in f.idxs\n        cosθ = cos(x[i])\n        cosθp= cos(x[f.idxsp1[i]] - x[i])\n        cosθm= cos(x[f.idxsm1[i]] - x[i])\n        J[i+M, i] = ks[i]*cosθ + Γ*(cosθp + cosθm)\n        J[i+M, f.idxsm1[i]] = - Γ*cosθm\n        J[i+M, f.idxsp1[i]] = - Γ*cosθp\n        J[i, i] = 1 + J[i+M, i]\n        J[i, f.idxsm1[i]] = J[i+M, f.idxsm1[i]]\n        J[i, f.idxsp1[i]] = J[i+M, f.idxsp1[i]]\n    end\n    return nothing\nend","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"This is possible because the system state is a Vector while the Jacobian is a Matrix, so multiple dispatch can differentiate between the two.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Notice in addition, that the Jacobian function accesses only half the elements of the matrix. This is intentional, and takes advantage of the fact that the other half is constant. We can leverage this further, by making the Jacobian a sparse matrix. Because the DynamicalSystem constructors allow us to give in a pre-initialized Jacobian matrix, we take advantage of that and create:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"using SparseArrays\nJ = zeros(eltype(u0), 2M, 2M)\n# Set ∂/∂p entries (they are eye(M,M))\n# And they dont change they are constants\nfor i in idxs\n    J[i, i+M] = 1\n    J[i+M, i+M] = 1\nend\nsparseJ = sparse(J)\n\ncsm(sparseJ, u0, p, 0) # apply Jacobian to initial state\nsparseJ","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Now we are ready to create our dynamical system","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ds = DeterministicIteratedMap(csm, u0, p)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Of course, the reason we went through all this trouble was to make a TangentDynamicalSystem, that can actually use the Jacobian function.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"tands = TangentDynamicalSystem(ds; J = csm, J0 = sparseJ, k = M)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"step!(tands, 5)\ncurrent_deviations(tands)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"(the deviation vectors will increase in magnitude rapidly because the dynamical system is chaotic)","category":"page"}]
}
