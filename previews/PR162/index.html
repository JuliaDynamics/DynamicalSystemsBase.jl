<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DynamicalSystemsBase.jl · DynamicalSystemsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DynamicalSystemsBase.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DynamicalSystemsBase.jl</a><ul class="internal"><li><a class="tocitem" href="#The-DynamicalSystem-API"><span>The <code>DynamicalSystem</code> API</span></a></li><li><a class="tocitem" href="#Time-evolution"><span>Time evolution</span></a></li><li><a class="tocitem" href="#DeterministicIteratedMap"><span><code>DeterministicIteratedMap</code></span></a></li><li><a class="tocitem" href="#CoupledODEs"><span><code>CoupledODEs</code></span></a></li><li><a class="tocitem" href="#StroboscopicMap"><span><code>StroboscopicMap</code></span></a></li><li><a class="tocitem" href="#PoincareMap"><span><code>PoincareMap</code></span></a></li><li><a class="tocitem" href="#ProjectedDynamicalSystem"><span><code>ProjectedDynamicalSystem</code></span></a></li><li><a class="tocitem" href="#ParallelDynamicalSystem"><span><code>ParallelDynamicalSystem</code></span></a></li><li><a class="tocitem" href="#TangentDynamicalSystem"><span><code>TangentDynamicalSystem</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DynamicalSystemsBase.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DynamicalSystemsBase.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DynamicalSystemsBase.jl"><a class="docs-heading-anchor" href="#DynamicalSystemsBase.jl">DynamicalSystemsBase.jl</a><a id="DynamicalSystemsBase.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DynamicalSystemsBase.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase" href="#DynamicalSystemsBase"><code>DynamicalSystemsBase</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DynamicalSystemsBase.jl</strong></p><p><a href="https://JuliaDynamics.github.io/DynamicalSystemsBase.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7"><img src="https://img.shields.io/badge/DOI-10.1007/978-3-030-91032-7-purple" alt/></a> <a href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/JuliaDynamics/DynamicalSystemsBase.jl"><img src="https://codecov.io/gh/JuliaDynamics/DynamicalSystemsBase.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://pkgs.genieframework.com?packages=DynamicalSystemsBase"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/DynamicalSystemsBase" alt="Package Downloads"/></a></p><p>A Julia package that defines the <code>DynamicalSystem</code> interface and many concrete implementations used in the <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a> ecosystem.</p><p>To install it, run <code>import Pkg; Pkg.add(&quot;DynamicalSystemsBase&quot;)</code>.</p><p>All further information is provided in the documentation, which you can either find <a href="https://juliadynamics.github.io/DynamicalSystemsBase.jl/dev/">online</a> or build locally by running the <code>docs/make.jl</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/DynamicalSystemsBase.jl#L4-L18">source</a></section></article><h2 id="The-DynamicalSystem-API"><a class="docs-heading-anchor" href="#The-DynamicalSystem-API">The <code>DynamicalSystem</code> API</a><a id="The-DynamicalSystem-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-DynamicalSystem-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicalSystem</code></pre><p><code>DynamicalSystem</code> is an abstract supertype encompassing all concrete implementations of what counts as a &quot;dynamical system&quot; in the DynamicalSystems.jl library.</p><p><strong><em>All concrete implementations of <code>DynamicalSystem</code> can be iteratively evolved in time via the <a href="#SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> function.</em></strong> Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on e.g., parallelization.</p><p><code>DynamicalSystem</code> is further separated into two abstract types: <code>ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem</code>. The simplest and most common concrete implementations of a <code>DynamicalSystem</code> are <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>.</p><p><strong>Description</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The documentation of <code>DynamicalSystem</code> follows chapter 1 of <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7">Nonlinear Dynamics</a>, Datseris &amp; Parlitz, Springer 2022.</p></div></div><p>A <code>ds::DynamicalSystem</code> <strong><em>representes a flow Φ in a state space</em></strong>. It mainly encapsulates three things:</p><ol><li>A state, typically referred to as <code>u</code>, with initial value <code>u0</code>. The space that <code>u</code> occupies is the state space of <code>ds</code> and the length of <code>u</code> is the dimension of <code>ds</code> (and of the state space).</li><li>A dynamic rule, typically referred to as <code>f</code>, that dictates how the state evolves/changes with time when calling the <a href="#SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>step!</code></a> function. <code>f</code> is a standard Julia function, see below.</li><li>A parameter container <code>p</code> that parameterizes <code>f</code>. <code>p</code> can be anything, but in general it is recommended to be a type-stable mutable container.</li></ol><p>In sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of <code>DynamicalSystem</code> are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.</p><p>In this scope dynamical systems have a known dynamic rule <code>f</code> defined as a standard Julia function. <em>Observed</em> or <em>measured</em> data from a dynamical system are represented using <code>AbstractDataset</code> and are finite. Such data are obtained from the <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> function or from an experimental measurement of a dynamical system with an unknown dynamic rule.</p><p><strong>Construction instructions on <code>f</code> and <code>u</code></strong></p><p>Most of the concrete implementations of <code>DynamicalSystem</code>, with the exception of <a href="@ref"><code>ArbitrarySteppable</code></a>, have two ways of implementing the dynamic rule <code>f</code>, and as a consequence the type of the state <code>u</code>. The distinction is done on whether <code>f</code> is defined as an in-place (iip) function or out-of-place (oop) function.</p><ul><li><strong>oop</strong> : <code>f</code> <strong>must</strong> be in the form <code>f(u, p, t) -&gt; out</code>   which means that given a state <code>u::SVector{&lt;:Real}</code> and some parameter container   <code>p</code> it returns the output of <code>f</code> as an <code>SVector{&lt;:Real}</code> (static vector).</li><li><strong>iip</strong> : <code>f</code> <strong>must</strong> be in the form <code>f!(out, u, p, t)</code>   which means that given a state <code>u::AbstractArray{&lt;:Real}</code> and some parameter container <code>p</code>,   it writes in-place the output of <code>f</code> in <code>out::AbstractArray{&lt;:Real}</code>.   The function <strong>must</strong> return <code>nothing</code> as a final statement.</li></ul><p><code>t</code> stands for current time in both cases. <strong>iip</strong> is suggested for systems with high dimension and <strong>oop</strong> for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of <code>f</code>.</p><div class="admonition is-info"><header class="admonition-header">Autonomous vs non-autonomous systems</header><div class="admonition-body"><p>Whether the dynamical system is autonomous (<code>f</code> doesn&#39;t depend on time) or not, it is still necessary to include <code>t</code> as an argument to <code>f</code>. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its <em>effective dimensionality</em> is <code>dimension(ds)+1</code>.</p></div></div><p><strong>API</strong></p><p>The API that the interface of <code>DynamicalSystem</code> employs is the functions listed below. Once a concrete instance of a subtype of <code>DynamicalSystem</code> is obtained, it can quieried or altered with the following functions.</p><p>The main use of a concrete dynamical system instance is to provide it to downstream functions such as <code>lyapunovspectrum</code> from ChaosTools.jl or <code>basins_of_attraction</code> from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.</p><p><strong>API - information</strong></p><ul><li><code>ds(t)</code> with <code>ds</code> an instance of <code>DynamicalSystem</code>: return the state of <code>ds</code> at time <code>t</code>. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if <code>t</code> is the current time.</li><li><a href="#DynamicalSystemsBase.current_state"><code>current_state</code></a></li><li><a href="#DynamicalSystemsBase.initial_state"><code>initial_state</code></a></li><li><a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a></li><li><a href="#DynamicalSystemsBase.initial_parameters"><code>initial_parameters</code></a></li><li><a href="#DynamicalSystemsBase.isdeterministic"><code>isdeterministic</code></a></li><li><a href="#DynamicalSystemsBase.isdiscretetime"><code>isdiscretetime</code></a></li><li><a href="#DynamicalSystemsBase.dynamic_rule"><code>dynamic_rule</code></a></li><li><a href="#DynamicalSystemsBase.current_time"><code>current_time</code></a></li><li><a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a></li><li><a href="#SciMLBase.isinplace-Tuple{DynamicalSystem}"><code>isinplace</code></a></li></ul><p><strong>API - alter status</strong></p><ul><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a></li><li><a href="#DynamicalSystemsBase.set_state!"><code>set_state!</code></a></li><li><a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a></li><li><a href="#DynamicalSystemsBase.set_parameters!"><code>set_parameters!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L4-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_state" href="#DynamicalSystemsBase.current_state"><code>DynamicalSystemsBase.current_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_state(ds::DynamicalSystem) → u</code></pre><p>Return the current state of <code>ds</code>. This state is mutated when <code>ds</code> is mutated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.initial_state" href="#DynamicalSystemsBase.initial_state"><code>DynamicalSystemsBase.initial_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_state(ds::DynamicalSystem) → u0</code></pre><p>Return the initial state of <code>ds</code>. This state is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_parameters" href="#DynamicalSystemsBase.current_parameters"><code>DynamicalSystemsBase.current_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_parameters(ds::DynamicalSystem) → p</code></pre><p>Return the current parameter container of <code>ds</code>. This is mutated in functions that need to evolve <code>ds</code> across a parameter range.</p><p>The following convenience syntax is also possible:</p><pre><code class="nohighlight hljs">current_parameters(ds::DynamicalSystem, index)</code></pre><p>which will give the specific parameter from the container at the given <code>index</code> (which works for arrays, dictionaries, or composite types if <code>index</code> is <code>Symbol</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L162-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.initial_parameters" href="#DynamicalSystemsBase.initial_parameters"><code>DynamicalSystemsBase.initial_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_parameters(ds::DynamicalSystem) → p0</code></pre><p>Return the initial parameter container of <code>ds</code>. This is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.isdeterministic" href="#DynamicalSystemsBase.isdeterministic"><code>DynamicalSystemsBase.isdeterministic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdeterministic(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if <code>ds</code> is deterministic, i.e., the dynamic rule contains no randomness. This is information deduced from the type of <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.isdiscretetime" href="#DynamicalSystemsBase.isdiscretetime"><code>DynamicalSystemsBase.isdiscretetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isdiscretetime(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if <code>ds</code> operates in discrete time, or <code>false</code> if it is in continuous time. This is information deduced from the type of <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L202-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.dynamic_rule" href="#DynamicalSystemsBase.dynamic_rule"><code>DynamicalSystemsBase.dynamic_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dynamic_rule(ds::DynamicalSystem) → f</code></pre><p>Return the dynamic rule of <code>ds</code>. This is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_time" href="#DynamicalSystemsBase.current_time"><code>DynamicalSystemsBase.current_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_time(ds::DynamicalSystem) → t</code></pre><p>Return the current time that <code>ds</code> is at. This is mutated when <code>ds</code> is evolved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.initial_time" href="#DynamicalSystemsBase.initial_time"><code>DynamicalSystemsBase.initial_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_time(ds::DynamicalSystem) → t0</code></pre><p>Return the initial time defined for <code>ds</code>. This is never mutated and is set when initializing <code>ds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L226-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.isinplace-Tuple{DynamicalSystem}" href="#SciMLBase.isinplace-Tuple{DynamicalSystem}"><code>SciMLBase.isinplace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinplace(ds::DynamicalSystem) → true/false</code></pre><p>Return <code>true</code> if the dynamic rule of <code>ds</code> is in-place, i.e., a function mutating the state in place. If <code>true</code>, the state is typically <code>Array</code>, if <code>false</code>, the state is typically <code>SVector</code>. A front-end user will most likely not care about this information, but a developer may care.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}" href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>SciMLBase.reinit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds</code></pre><p>Reset the status of <code>ds</code>, so that it is as if it has be just initialized with initial state <code>u</code>. Practically every function of the ecosystem that evolves <code>ds</code> first calls this function on it. Besides the new initial state <code>u</code>, you can also configure the keywords <code>t0 = initial_time(ds)</code> and <code>p = current_parameters(ds)</code>.</p><p>Note the default settings: the state and time are the initial, but the parameters are the current.</p><p>The special method <code>reinit!(ds, ::Nothing; kwargs...)</code> is also available, which does nothing and leaves the system as is. This is so that downstream functions that call <code>reinit!</code> can still be used without resetting the system but rather continuing from its exact current state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L313-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_state!" href="#DynamicalSystemsBase.set_state!"><code>DynamicalSystemsBase.set_state!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_state!(ds::DynamicalSystem, u)</code></pre><p>Set the state of <code>ds</code> to <code>u</code>, which must match dimensionality with that of <code>ds</code>. Also ensure that the change is notified to whatever integration protocol is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_parameter!" href="#DynamicalSystemsBase.set_parameter!"><code>DynamicalSystemsBase.set_parameter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_parameter!(ds::DynamicalSystem, index, value)</code></pre><p>Change a parameter of <code>ds</code> given the <code>index</code> it has in the parameter container and the <code>value</code> to set it to. This function works for both array/dictionary containers as well as composite types. In the latter case <code>index</code> needs to be a <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L258-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_parameters!" href="#DynamicalSystemsBase.set_parameters!"><code>DynamicalSystemsBase.set_parameters!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_parameters!(ds::DynamicalSystem, p = initial_parameters(ds))</code></pre><p>Set the parameter values in the <a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a><code>(ds)</code> to match <code>p</code>. This is done as an in-place overwrite by looping over the keys of <code>p</code>. Hence the keys of <code>p</code> must be a subset of the keys of <a href="#DynamicalSystemsBase.current_parameters"><code>current_parameters</code></a><code>(ds)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L276-L282">source</a></section></article><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}" href="#SciMLBase.step!-Tuple{DynamicalSystem, Vararg{Any}}"><code>SciMLBase.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(ds::DiscreteTimeDynamicalSystem [, dt::Integer]) → ds</code></pre><p>Evolve the discrete time dynamical system for 1 or <code>dt</code> steps.</p><pre><code class="nohighlight hljs">step!(ds::ContinuousTimeDynamicalSystem, [, dt::Real [, stop_at_tdt]]) → ds</code></pre><p>Evolve the continuous time dynamical system for one integration step.</p><p>Alternative, if a <code>dt</code> is given, then progress the integration until there is a temporal difference <code>≥ dt</code> (so, step <em>at least</em> for <code>dt</code> time).</p><p>When <code>true</code> is passed to the optional third argument, the integration advances for exactly <code>dt</code> time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/dynamicalsystem_interface.jl#L296-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.trajectory" href="#DynamicalSystemsBase.trajectory"><code>DynamicalSystemsBase.trajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trajectory(ds::DynamicalSystem, T [, u0]; kwargs...) → X, t</code></pre><p>Return a dataset <code>X</code> that will contain the trajectory of the system <code>ds</code>, after evolving it for total time <code>T</code>. <code>u0</code> is the state given given to <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> prior to time evolution and defaults to <a href="#DynamicalSystemsBase.initial_state"><code>initial_state(ds)</code></a>.</p><p>See <a href="#StateSpaceSets.Dataset"><code>Dataset</code></a> for info on how to use <code>X</code>. The returned time vector is <code>t = (t0+Ttr):Δt:(t0+Ttr+T)</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Δt</code>:  Time step of value output. For discrete time systems it must be an integer. Defaults to <code>0.1</code> for continuous and <code>1</code> for discrete time systems.</li><li><code>Ttr = 0</code>: Transient time to evolve the initial state before starting saving states.</li><li><code>t0 = initial_time(ds)</code>: Starting time.</li><li><code>save_idxs::AbstractVector{Int}</code>: Which variables to output in <code>X</code> (by default all).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core/trajectory.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.Dataset" href="#StateSpaceSets.Dataset"><code>StateSpaceSets.Dataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dataset{D, T} &lt;: AbstractDataset{D,T}</code></pre><p>A dedicated interface for datasets. It contains <em>equally-sized datapoints</em> of length <code>D</code>, represented by <code>SVector{D, T}</code>. These data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(dataset)</code>.</p><p>When indexed with 1 index, a <code>dataset</code> is like a vector of datapoints. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables.</p><p><code>Dataset</code> also supports most sensible operations like <code>append!, push!, hcat, eachrow</code>, among others, and when iterated over, it iterates over its contained points.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers,  <code>typeof(data) &lt;: AbstractDataset</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for massive performance benefits make <code>v2</code> an <code>SVector{X, Int}</code>).</p><ul><li><code>data[i] == data[i, :]</code> gives the <code>i</code>th datapoint (returns an <code>SVector</code>)</li><li><code>data[v1] == data[v1, :]</code>, returns a <code>Dataset</code> with the points in those indices.</li><li><code>data[:, j]</code> gives the <code>j</code>th variable timeseries, as <code>Vector</code></li><li><code>data[v1, v2], data[:, v2]</code> returns a <code>Dataset</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>data[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(dataset)</code> or <code>Dataset(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>Dataset(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div></section></article><h2 id="DeterministicIteratedMap"><a class="docs-heading-anchor" href="#DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a><a id="DeterministicIteratedMap-1"></a><a class="docs-heading-anchor-permalink" href="#DeterministicIteratedMap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DeterministicIteratedMap" href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DynamicalSystemsBase.DeterministicIteratedMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeterministicIteratedMap &lt;: DynamicalSystem
DeterministicIteratedMap(f, u0, p = nothing; t0 = 0)</code></pre><p>A deterministic discrete time dynamical system defined by an iterated map as follows:</p><p class="math-container">\[\vec{u}_{n+1} = \vec{f}(\vec{u}_n, p, n)\]</p><p>An alias for <code>DeterministicIteratedMap</code> is <code>DiscreteDynamicalSystem</code>.</p><p>Optionally configure the parameter container <code>p</code> and initial time <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core_systems/discrete_time_map.jl#L7-L20">source</a></section></article><h2 id="CoupledODEs"><a class="docs-heading-anchor" href="#CoupledODEs"><code>CoupledODEs</code></a><a id="CoupledODEs-1"></a><a class="docs-heading-anchor-permalink" href="#CoupledODEs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.CoupledODEs" href="#DynamicalSystemsBase.CoupledODEs"><code>DynamicalSystemsBase.CoupledODEs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoupledODEs &lt;: ContinuousTimeDynamicalSystem
CoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)</code></pre><p>A deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:</p><p class="math-container">\[\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}, p, t)\]</p><p>An alias for <code>CoupledODE</code> is <code>ContinuousDynamicalSystem</code>.</p><p>Optionally provide the parameter container <code>p</code> and initial time as keyword <code>t0</code>.</p><p>For construction instructions regarding <code>f, u0</code> see <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a>.</p><p><strong>DifferentialEquations.jl keyword arguments and interfacing</strong></p><p>The ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a <code>CoupledODEs</code>, you can specify the solver that will integrate <code>f</code> in time, along with any other integration options, using the <code>diffeq</code> keyword. For example you could use <code>diffeq = (abstol = 1e-9, reltol = 1e-9)</code>. If you want to specify a solver, do so by using the keyword <code>alg</code>, e.g.: <code>diffeq = (alg = Tsit5(), maxiters = 100000)</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers. The default <code>diffeq</code> is:</p><p>(alg = Tsit5(stage<em>limiter! = trivial</em>limiter!, step<em>limiter! = trivial</em>limiter!, thread = static(false)), abstol = 1.0e-6, reltol = 1.0e-6)</p><p><code>diffeq</code> keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling </a>, however the majority of downstream functions in DynamicalSystems.jl assume that <code>f</code> is differentiable.</p><p>The convenience constructor <code>CoupledODEs(prob::ODEProblem, diffeq)</code> is also available.</p><p>Dev note: <code>CoupledODEs</code> is a light wrapper of <code>ODEIntegrator</code> from DifferentialEquations.jl. The integrator is available as the field <code>integ</code>, and the <code>ODEProblem</code> is <code>integ.sol.prob</code>. The convenience syntax <code>ODEProblem(ds::CoupledODEs, tspan = (t0, Inf))</code> is available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core_systems/continuous_time_ode.jl#L27-L63">source</a></section></article><h2 id="StroboscopicMap"><a class="docs-heading-anchor" href="#StroboscopicMap"><code>StroboscopicMap</code></a><a id="StroboscopicMap-1"></a><a class="docs-heading-anchor-permalink" href="#StroboscopicMap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.StroboscopicMap" href="#DynamicalSystemsBase.StroboscopicMap"><code>DynamicalSystemsBase.StroboscopicMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StroboscopicMap &lt;: DiscreteTimeDynamicalSystem
StroboscopicMap(ds::CoupledODEs, T::Real) → smap</code></pre><p>A discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> system exactly over a period <code>T</code>. This is known as a stroboscopic map. The second signature creates a <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a> and calls the first (with <code>t0</code> measured in continuous time).</p><p>As this system is in discrete time, <a href="@Ref"><code>current_time</code></a> and <a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a> are integers. The initial time is always 0, because <code>current_time</code> counts elapsed periods. Call these functions on the field <code>.ds</code> of <code>StroboscopicMap</code> to obtain the corresponding continuous time. In contrast, <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> expects <code>t0</code> in continuous time.</p><p>The convenience constructor</p><pre><code class="language-julia hljs">StroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap</code></pre><p>is also provided.</p><p>See also <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/stroboscopic_map.jl#L6-L29">source</a></section></article><h2 id="PoincareMap"><a class="docs-heading-anchor" href="#PoincareMap"><code>PoincareMap</code></a><a id="PoincareMap-1"></a><a class="docs-heading-anchor-permalink" href="#PoincareMap" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.PoincareMap" href="#DynamicalSystemsBase.PoincareMap"><code>DynamicalSystemsBase.PoincareMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoincareMap &lt;: DiscreteTimeDynamicalSystem
PoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap</code></pre><p>A discrete time dynamical system that produces iterations over the Poincaré map<sup class="footnote-reference"><a id="citeref-DatserisParlitz2022" href="#footnote-DatserisParlitz2022">[DatserisParlitz2022]</a></sup> of the given continuous time <code>ds</code>. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the <code>plane</code> argument.</p><p>See also <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a>, <a href="#DynamicalSystemsBase.poincaresos"><code>poincaresos</code></a>, <a href="@ref"><code>produce_orbitdiagram</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>direction = -1</code>: Only crossings with <code>sign(direction)</code> are considered to belong to the surface of section. Positive direction means going from less than <span>$b$</span> to greater than <span>$b$</span>.</li><li><code>u0 = nothing</code>: Specify an initial state.</li><li><code>rootkw = (xrtol = 1e-6, atol = 1e-6)</code>: A <code>NamedTuple</code> of keyword arguments passed to <code>find_zero</code> from <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a>.</li><li><code>Tmax = 1e3</code>: The argument <code>Tmax</code> exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one <code>step!</code> the system has been evolved for more than <code>Tmax</code>, then <code>step!(pmap)</code> will terminate and error.</li></ul><p><strong>Description</strong></p><p>The Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. <code>PoincareMap</code> iterates over the crossings of the section.</p><p>If the state of <code>ds</code> is <span>$\mathbf{u} = (u_1, \ldots, u_D)$</span> then the equation defining a hyperplane is</p><p class="math-container">\[a_1u_1 + \dots + a_Du_D = \mathbf{a}\cdot\mathbf{u}=b\]</p><p>where <span>$\mathbf{a}, b$</span> are the parameters of the hyperplane.</p><p>In code, <code>plane</code> can be either:</p><ul><li>A <code>Tuple{Int, &lt;: Real}</code>, like <code>(j, r)</code>: the plane is defined as when the <code>j</code>th variable of the system equals the value <code>r</code>.</li><li>A vector of length <code>D+1</code>. The first <code>D</code> elements of the vector correspond to <span>$\mathbf{a}$</span> while the last element is <span>$b$</span>.</li></ul><p><code>PoincareMap</code> uses <code>ds</code>, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.</p><p><code>PoincareMap</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ol><li><code>dimension(pmap) == dimension(ds)</code>, even though the Poincaré map is effectively 1 dimension less.</li><li>Like <a href="#DynamicalSystemsBase.StroboscopicMap"><code>StroboscopicMap</code></a> time is discrete and counts the iterations on the surface of section. <a href="#DynamicalSystemsBase.initial_time"><code>initial_time</code></a> is always <code>0</code> and <a href="#DynamicalSystemsBase.current_time"><code>current_time</code></a> is current iteration number.</li><li>A new function <a href="#DynamicalSystemsBase.current_crossing_time"><code>current_crossing_time</code></a> returns the real time corresponding to the latest crossing of the hyperplane, which is what the <a href="#DynamicalSystemsBase.current_state"><code>current_state(ds)</code></a> corresponds to as well.</li><li>For the special case of <code>plane</code> being a <code>Tuple{Int, &lt;:Real}</code>, a special <code>reinit!</code> method is allowed with input state of length <code>D-1</code> instead of <code>D</code>, i.e., a reduced state already on the hyperplane that is then converted into the <code>D</code> dimensional state.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using DynamicalSystemsBase
ds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)
pmap = poincaremap(ds, (3, 0.0))
step!(pmap)
next_state_on_psos = current_state(pmap)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/poincare/poincaremap.jl#L12-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_crossing_time" href="#DynamicalSystemsBase.current_crossing_time"><code>DynamicalSystemsBase.current_crossing_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_crossing_time(pmap::PoincareMap) → tcross</code></pre><p>Return the time of the latest crossing of the Poincare section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/poincare/poincaremap.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.poincaresos" href="#DynamicalSystemsBase.poincaresos"><code>DynamicalSystemsBase.poincaresos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">poincaresos(A::AbstractDataset, plane; kwargs...) → P::Dataset</code></pre><p>Calculate the Poincaré surface of section of the given dataset with the given <code>plane</code> by performing linear interpolation betweeen points that sandwich the hyperplane.</p><p>Argument <code>plane</code> and keywords <code>direction, warning, save_idxs</code> are the same as in the method below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/poincare/hyperplane.jl#L77-L85">source</a></section><section><div><pre><code class="nohighlight hljs">poincaresos(ds::CoupledODEs, plane, T = 1000.0; kwargs...) → P::Dataset</code></pre><p>Return the iterations of <code>ds</code> on the Poincaré surface of section with the <code>plane</code>, by evolving <code>ds</code> up to a total of <code>T</code>. Return a <a href="#StateSpaceSets.Dataset"><code>Dataset</code></a> of the points that are on the surface of section.</p><p>This function initializes a <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> and steps it until its <a href="#DynamicalSystemsBase.current_crossing_time"><code>current_crossing_time</code></a> exceeds <code>T</code>. You can also use <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> with <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> to get a sequence of <code>N::Int</code> points instead.</p><p>The keywords <code>Ttr, save_idxs</code> act as in <a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a>. See <a href="#DynamicalSystemsBase.PoincareMap"><code>PoincareMap</code></a> for <code>plane</code> and all other keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/poincare/poincaremap.jl#L238-L251">source</a></section></article><h2 id="ProjectedDynamicalSystem"><a class="docs-heading-anchor" href="#ProjectedDynamicalSystem"><code>ProjectedDynamicalSystem</code></a><a id="ProjectedDynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#ProjectedDynamicalSystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.ProjectedDynamicalSystem" href="#DynamicalSystemsBase.ProjectedDynamicalSystem"><code>DynamicalSystemsBase.ProjectedDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedDynamicalSystem &lt;: DynamicalSystem
ProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)</code></pre><p>A dynamical system that represents a projection of an existing <code>ds</code> on a (projected) space.</p><p>The <code>projection</code> defines the projected space. If <code>projection isa AbstractVector{Int}</code>, then the projected space is simply the variable indices that <code>projection</code> contains. Otherwise, <code>projection</code> can be an arbitrary function that given the state of the original system <code>ds</code>, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.</p><p><code>complete_state</code> produces the state for the original system from the projected state. <code>complete_state</code> can always be a function that given the projected state returns a state in the original space. However, if <code>projection isa AbstractVector{Int}</code>, then <code>complete_state</code> can also be a vector that contains the values of the <em>remaining</em> variables of the system, i.e., those <em>not</em> contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.</p><p>Notice that <code>ProjectedDynamicalSystem</code> does not require an invertible projection, <code>complete_state</code> is only used during <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a>. <code>ProjectedDynamicalSystem</code> is in fact a rather trivial wrapper of <code>ds</code> which steps it as normal in the original state space and only projects as a last step, e.g., during <a href="#DynamicalSystemsBase.current_state"><code>current_state</code></a>.</p><p><strong>Examples</strong></p><p>Case 1: project 5-dimensional system to its last two dimensions.</p><pre><code class="language-julia hljs">ds = Systems.lorenz96(5)
projection = [4, 5]
complete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions
pds = projected_integrator(ds, projection, complete_state)
reinit!(pds, [0.2, 0.4])
step!(pds)
get_state(pds)</code></pre><p>Case 2: custom projection to general functions of state. <code>julia ds = Systems.lorenz96(5) projection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)] complete_state(y) = repeat(y[1]/5, 5) pds = # same as in above example...</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/projected_system.jl#L6-L49">source</a></section></article><h2 id="ParallelDynamicalSystem"><a class="docs-heading-anchor" href="#ParallelDynamicalSystem"><code>ParallelDynamicalSystem</code></a><a id="ParallelDynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#ParallelDynamicalSystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.ParallelDynamicalSystem" href="#DynamicalSystemsBase.ParallelDynamicalSystem"><code>DynamicalSystemsBase.ParallelDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParallelDynamicalSystem &lt;: DynamicalSystem
ParallelDynamicalSystem(ds::DynamicalSystem, states::Vector{&lt;:AbstractArray})</code></pre><p>A struct that evolves several <code>states</code> of a given dynamical system in parallel <strong>at exactly the same times</strong>. Useful when wanting to evolve several different trajectories of the same system while ensuring that they share parameters and time vector.</p><p>This struct follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li>The function <a href="#DynamicalSystemsBase.current_state"><code>current_state</code></a> is called as <code>current_state(pds, i::Int = 1)</code> which returns the <code>i</code>th state. Same for <a href="#DynamicalSystemsBase.initial_state"><code>initial_state</code></a>.</li><li>Similarly, <a href="#DynamicalSystemsBase.set_state!"><code>set_state!</code></a> obtains a second argument <code>i::Int = 1</code> to set the <code>i</code>-th state.</li><li><a href="#DynamicalSystemsBase.current_states"><code>current_states</code></a> and <a href="#DynamicalSystemsBase.initial_states"><code>initial_states</code></a> can be used to get all parallel states.</li><li><a href="#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}"><code>reinit!</code></a> takes in a vector of states (like <code>states</code>) for <code>u</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/parallel_systems.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.initial_states" href="#DynamicalSystemsBase.initial_states"><code>DynamicalSystemsBase.initial_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initial_states(pds::ParallelDynamicalSystem)</code></pre><p>Return an iterator over the initial parallel states of <code>pds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/parallel_systems.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_states" href="#DynamicalSystemsBase.current_states"><code>DynamicalSystemsBase.current_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_states(pds::ParallelDynamicalSystem)</code></pre><p>Return an iterator over the parallel states of <code>pds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/parallel_systems.jl#L114-L118">source</a></section></article><h2 id="TangentDynamicalSystem"><a class="docs-heading-anchor" href="#TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a><a id="TangentDynamicalSystem-1"></a><a class="docs-heading-anchor-permalink" href="#TangentDynamicalSystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.CoreDynamicalSystem" href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>DynamicalSystemsBase.CoreDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoreDynamicalSystem</code></pre><p>Union type meaning either <a href="#DynamicalSystemsBase.DeterministicIteratedMap"><code>DeterministicIteratedMap</code></a> or <a href="#DynamicalSystemsBase.CoupledODEs"><code>CoupledODEs</code></a>, which are the core systems whose dynamic rule <code>f</code> is known analytically.</p><p>This type is used for deciding whether a creation of a <a href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>TangentDynamicalSystem</code></a> is possible or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/core_systems/additional_supertypes.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.TangentDynamicalSystem" href="#DynamicalSystemsBase.TangentDynamicalSystem"><code>DynamicalSystemsBase.TangentDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TangentDynamicalSystem &lt;: DynamicalSystem
TangentDynamicalSystem(ds::CoreDynamicalSystem; kwargs...)</code></pre><p>A dynamical system that bundles the evolution of <code>ds</code> (which must be an <a href="#DynamicalSystemsBase.CoreDynamicalSystem"><code>CoreDynamicalSystem</code></a>) and <code>k</code> deviation vectors that are evolved according to the <em>dynamics in the tangent space</em> (also called linearized dynamics or the tangent dynamics).</p><p>The state of <code>ds</code> <strong>must</strong> be an <code>AbstractVector</code> for <code>TangentDynamicalSystem</code>.</p><p><code>TangentDynamicalSystem</code> follows the <a href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> interface with the following adjustments:</p><ul><li><code>reinit!</code> takes an additional keyword <code>Q0</code> (with same default as below)</li><li>The additional functions <a href="#DynamicalSystemsBase.current_deviations"><code>current_deviations</code></a> and <a href="#DynamicalSystemsBase.set_deviations!"><code>set_deviations!</code></a> are provided for the deviation vectors.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>k</code> or <code>Q0</code>: <code>Q0</code> represents the initial deviation vectors (each column = 1 vector). If <code>k::Int</code> is given, a matrix <code>Q0</code> is created with the first <code>k</code> columns of the identity matrix. Otherwise <code>Q0</code> can be given directly as a matrix. It must hold that <code>size(Q, 1) == dimension(ds)</code>. You can use <a href="#StateSpaceSets.orthonormal"><code>orthonormal</code></a> for random orthonormal vectors. By default <code>k = dimension(ds)</code> is used.</li><li><code>u0 = current_state(ds)</code>: Starting state.</li><li><code>J</code> and <code>J0</code>: See section &quot;Jacobian&quot; below.</li></ul><p><strong>Description</strong></p><p>Let <span>$u$</span> be the state of <code>ds</code>, and <span>$y$</span> a deviation (or perturbation) vector. These two are evolved in parallel according to</p><p class="math-container">\[\begin{array}{rcl}
\frac{d\vec{x}}{dt} &amp;=&amp; f(\vec{x}) \\
\frac{dY}{dt} &amp;=&amp; J_f(\vec{x}) \cdot Y
\end{array}
\quad \mathrm{or}\quad
\begin{array}{rcl}
\vec{x}_{n+1} &amp;=&amp; f(\vec{x}_n) \\
Y_{n+1} &amp;=&amp; J_f(\vec{x}_n) \cdot Y_n.
\end{array}\]</p><p>for continuous or discrete time respectively. Here <span>$f$</span> is the <a href="#DynamicalSystemsBase.dynamic_rule"><code>dynamic_rule</code></a><code>(ds)</code> and <span>$J_f$</span> is the Jacobian of <span>$f$</span>.</p><p><strong>Jacobian</strong></p><p>The keyword <code>J</code> provides the Jacobian function. It must be a Julia function in the same form as <code>f</code>, the <a href="#DynamicalSystemsBase.dynamic_rule"><code>dynamic_rule</code></a>. Specifically, <code>J(u, p, n) -&gt; M::SMatrix</code> for the out-of-place version or <code>J(M, u, p, n)</code> for the in-place version acting in-place on <code>M</code>. in both cases <code>M</code> is a matrix whose columns are the deviation vectors.</p><p>By default <code>J = nothing</code>.  In this case <code>J</code> is constructed automatically using the module <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff</code></a>, hence its limitations also apply here. Even though <code>ForwardDiff</code> is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so it is recommended. Additionally, automatic and in-place Jacobians cannot be time dependent.</p><p>The keyword <code>J0</code> allows you to pass an initialized Jacobian matrix <code>J0</code>. This is useful for large in-place systems where only a few components of the Jacobian change during the time evolution. <code>J0</code> can be a sparse or any other matrix type. If not given, a matrix of zeros is used. <code>J0</code> is ignored for out of place systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/tangent_space.jl#L15-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_deviations" href="#DynamicalSystemsBase.current_deviations"><code>DynamicalSystemsBase.current_deviations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_deviations(tands::TangentDynamicalSystem)</code></pre><p>Return the deviation vectors of <code>tands</code> as a matrix with each column a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/tangent_space.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_deviations!" href="#DynamicalSystemsBase.set_deviations!"><code>DynamicalSystemsBase.set_deviations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_deviations!(tands::TangentDynamicalSystem, Q)</code></pre><p>Set the deviation vectors of <code>tands</code> to be <code>Q</code>, a matrix with each column a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DynamicalSystemsBase.jl/blob/1110018fd51b40f2538c40dde1b72630a5b652cd/src/derived_systems/tangent_space.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.orthonormal" href="#StateSpaceSets.orthonormal"><code>StateSpaceSets.orthonormal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orthonormal([T,] D, k) -&gt; ws</code></pre><p>Return a matrix <code>ws</code> with <code>k</code> columns, each being an <code>D</code>-dimensional orthonormal vector. <code>T</code> is the return type and can be either <code>SMatrix</code> or <code>Matrix</code></p><p>returns either SMatrix{D, k} if D*k &lt; 100, otherwise Dxk Matrix{Float64}</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-DatserisParlitz2022"><a class="tag is-link" href="#citeref-DatserisParlitz2022">DatserisParlitz2022</a>Datseris &amp; Parlitz 2022, <em>Nonlinear Dynamics: A Concise Introduction Interlaced with Code</em>, <a href="https://doi.org/10.1007/978-3-030-91032-7">Springer Nature, Undergrad. Lect. Notes In Physics</a></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 February 2023 19:31">Thursday 9 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
