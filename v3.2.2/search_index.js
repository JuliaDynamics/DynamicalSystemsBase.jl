var documenterSearchIndex = {"docs":
[{"location":"#DynamicalSystemsBase.jl","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"DynamicalSystemsBase","category":"page"},{"location":"#DynamicalSystemsBase","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase","text":"DynamicalSystemsBase.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that defines the DynamicalSystem interface and many concrete implementations used in the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystemsBase\"). Typically, you do not want to use DynamicalSystemsBase directly, as downstream analysis packages re-export it.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"#The-DynamicalSystem-API","page":"DynamicalSystemsBase.jl","title":"The DynamicalSystem API","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"DynamicalSystem","category":"page"},{"location":"#DynamicalSystemsBase.DynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.DynamicalSystem","text":"DynamicalSystem\n\nDynamicalSystem is an abstract supertype encompassing all concrete implementations of what counts as a \"dynamical system\" in the DynamicalSystems.jl library.\n\nAll concrete implementations of DynamicalSystem can be iteratively evolved in time via the step! function. Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on for parallelization.\n\nDynamicalSystem is further separated into two abstract types: ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem. The simplest and most common concrete implementations of a DynamicalSystem are DeterministicIteratedMap or CoupledODEs.\n\nDescription\n\nnote: Note\nThe documentation of DynamicalSystem follows chapter 1 of Nonlinear Dynamics, Datseris & Parlitz, Springer 2022.\n\nA ds::DynamicalSystem representes a flow Φ in a state space. It mainly encapsulates three things:\n\nA state, typically referred to as u, with initial value u0. The space that u occupies is the state space of ds and the length of u is the dimension of ds (and of the state space).\nA dynamic rule, typically referred to as f, that dictates how the state evolves/changes with time when calling the step! function. f is a standard Julia function, see below.\nA parameter container p that parameterizes f. p can be anything, but in general it is recommended to be a type-stable mutable container.\n\nIn sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of DynamicalSystem are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.\n\nIn this scope dynamical systems have a known dynamic rule f defined as a standard Julia function. Observed or measured data from a dynamical system are represented using StateSpaceSet and are finite. Such data are obtained from the trajectory function or from an experimental measurement of a dynamical system with an unknown dynamic rule.\n\nConstruction instructions on f and u\n\nMost of the concrete implementations of DynamicalSystem, with the exception of ArbitrarySteppable, have two ways of implementing the dynamic rule f, and as a consequence the type of the state u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.\n\noop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.\n\nt stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.\n\nnote: Autonomous vs non-autonomous systems\nWhether the dynamical system is autonomous (f doesn't depend on time) or not, it is still necessary to include t as an argument to f. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its effective dimensionality is dimension(ds)+1.\n\nAPI\n\nThe API that the interface of DynamicalSystem employs is the functions listed below. Once a concrete instance of a subtype of DynamicalSystem is obtained, it can quieried or altered with the following functions.\n\nThe main use of a concrete dynamical system instance is to provide it to downstream functions such as lyapunovspectrum from ChaosTools.jl or basins_of_attraction from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.\n\nAPI - information\n\nds(t) with ds an instance of DynamicalSystem: return the state of ds at time t. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if t is the current time.\ncurrent_state\ninitial_state\ncurrent_parameters\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace\nsuccesful_step\n\nAPI - alter status\n\nreinit!\nset_state!\nset_parameter!\nset_parameters!\n\n\n\n\n\n","category":"type"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"current_state\ninitial_state\ncurrent_parameters\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace(::DynamicalSystem)\nsuccessful_step","category":"page"},{"location":"#DynamicalSystemsBase.current_state","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_state","text":"current_state(ds::DynamicalSystem) → u\n\nReturn the current state of ds. This state is mutated when ds is mutated.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.initial_state","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_state","text":"initial_state(ds::DynamicalSystem) → u0\n\nReturn the initial state of ds. This state is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_parameters","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_parameters","text":"current_parameters(ds::DynamicalSystem) → p\n\nReturn the current parameter container of ds. This is mutated in functions that need to evolve ds across a parameter range.\n\nThe following convenience syntax is also possible:\n\ncurrent_parameters(ds::DynamicalSystem, index)\n\nwhich will give the specific parameter from the container at the given index (which works for arrays, dictionaries, or composite types if index is Symbol).\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.initial_parameters","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_parameters","text":"initial_parameters(ds::DynamicalSystem) → p0\n\nReturn the initial parameter container of ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.isdeterministic","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.isdeterministic","text":"isdeterministic(ds::DynamicalSystem) → true/false\n\nReturn true if ds is deterministic, i.e., the dynamic rule contains no randomness. This is information deduced from the type of ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.isdiscretetime","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.isdiscretetime","text":"isdiscretetime(ds::DynamicalSystem) → true/false\n\nReturn true if ds operates in discrete time, or false if it is in continuous time. This is information deduced from the type of ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.dynamic_rule","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.dynamic_rule","text":"dynamic_rule(ds::DynamicalSystem) → f\n\nReturn the dynamic rule of ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_time","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_time","text":"current_time(ds::DynamicalSystem) → t\n\nReturn the current time that ds is at. This is mutated when ds is evolved.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.initial_time","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_time","text":"initial_time(ds::DynamicalSystem) → t0\n\nReturn the initial time defined for ds. This is never mutated and is set when initializing ds.\n\n\n\n\n\n","category":"function"},{"location":"#SciMLBase.isinplace-Tuple{DynamicalSystem}","page":"DynamicalSystemsBase.jl","title":"SciMLBase.isinplace","text":"isinplace(ds::DynamicalSystem) → true/false\n\nReturn true if the dynamic rule of ds is in-place, i.e., a function mutating the state in place. If true, the state is typically Array, if false, the state is typically SVector. A front-end user will most likely not care about this information, but a developer may care.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicalSystemsBase.successful_step","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.successful_step","text":"successful_step(ds::DynamicalSystem) -> true/false\n\nReturn true if the last step! call to ds was successful, false otherwise. For continuous time systems this uses DifferentialEquations.jl error checking, for discrete time it checks if any variable is Inf or NaN.\n\n\n\n\n\n","category":"function"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"reinit!(::DynamicalSystem, args...; kwargs...)\nset_state!\nset_parameter!\nset_parameters!","category":"page"},{"location":"#SciMLBase.reinit!-Tuple{DynamicalSystem, Vararg{Any}}","page":"DynamicalSystemsBase.jl","title":"SciMLBase.reinit!","text":"reinit!(ds::DynamicalSystem, u = initial_state(ds); kwargs...) → ds\n\nReset the status of ds, so that it is as if it has be just initialized with initial state u. Practically every function of the ecosystem that evolves ds first calls this function on it. Besides the new initial state u, you can also configure the keywords t0 = initial_time(ds) and p = current_parameters(ds).\n\nNote the default settings: the state and time are the initial, but the parameters are the current.\n\nThe special method reinit!(ds, ::Nothing; kwargs...) is also available, which does nothing and leaves the system as is. This is so that downstream functions that call reinit! can still be used without resetting the system but rather continuing from its exact current state.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicalSystemsBase.set_state!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_state!","text":"set_state!(ds::DynamicalSystem, u)\n\nSet the state of ds to u, which must match dimensionality with that of ds. Also ensure that the change is notified to whatever integration protocol is used.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.set_parameter!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_parameter!","text":"set_parameter!(ds::DynamicalSystem, index, value)\n\nChange a parameter of ds given the index it has in the parameter container and the value to set it to. This function works for both array/dictionary containers as well as composite types. In the latter case index needs to be a Symbol.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.set_parameters!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_parameters!","text":"set_parameters!(ds::DynamicalSystem, p = initial_parameters(ds))\n\nSet the parameter values in the current_parameters(ds) to match p. This is done as an in-place overwrite by looping over the keys of p. Hence the keys of p must be a subset of the keys of current_parameters(ds).\n\n\n\n\n\n","category":"function"},{"location":"#Time-evolution","page":"DynamicalSystemsBase.jl","title":"Time evolution","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"step!(::DynamicalSystem, args...; kwargs...)\ntrajectory\nStateSpaceSet","category":"page"},{"location":"#CommonSolve.step!-Tuple{DynamicalSystem, Vararg{Any}}","page":"DynamicalSystemsBase.jl","title":"CommonSolve.step!","text":"step!(ds::DiscreteTimeDynamicalSystem [, n::Integer]) → ds\n\nEvolve the discrete time dynamical system for 1 or n steps.\n\nstep!(ds::ContinuousTimeDynamicalSystem, [, dt::Real [, stop_at_tdt]]) → ds\n\nEvolve the continuous time dynamical system for one integration step.\n\nAlternatively, if a dt is given, then progress the integration until there is a temporal difference ≥ dt (so, step at least for dt time).\n\nWhen true is passed to the optional third argument, the integration advances for exactly dt time.\n\n\n\n\n\n","category":"method"},{"location":"#DynamicalSystemsBase.trajectory","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.trajectory","text":"trajectory(ds::DynamicalSystem, T [, u0]; kwargs...) → X, t\n\nReturn a dataset X that will contain the trajectory of the system ds, after evolving it for total time T. u0 is the state given given to reinit! prior to time evolution and defaults to initial_state(ds).\n\nSee StateSpaceSet for info on how to use X. The returned time vector is t = (t0+Ttr):Δt:(t0+Ttr+T).\n\nKeyword arguments\n\nΔt:  Time step of value output. For discrete time systems it must be an integer. Defaults to 0.1 for continuous and 1 for discrete time systems. If you don't have access to unicode, the keyword Dt can be used instead.\nTtr = 0: Transient time to evolve the initial state before starting saving states.\nt0 = initial_time(ds): Starting time.\nsave_idxs::AbstractVector{Int}: Which variables to output in X (by default all).\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.StateSpaceSet","page":"DynamicalSystemsBase.jl","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"#DeterministicIteratedMap","page":"DynamicalSystemsBase.jl","title":"DeterministicIteratedMap","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"DeterministicIteratedMap","category":"page"},{"location":"#DynamicalSystemsBase.DeterministicIteratedMap","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.DeterministicIteratedMap","text":"DeterministicIteratedMap <: DynamicalSystem\nDeterministicIteratedMap(f, u0, p = nothing; t0 = 0)\n\nA deterministic discrete time dynamical system defined by an iterated map as follows:\n\nvecu_n+1 = vecf(vecu_n p n)\n\nAn alias for DeterministicIteratedMap is DiscreteDynamicalSystem.\n\nOptionally configure the parameter container p and initial time t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\n\n\n\n\n","category":"type"},{"location":"#CoupledODEs","page":"DynamicalSystemsBase.jl","title":"CoupledODEs","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"CoupledODEs","category":"page"},{"location":"#DynamicalSystemsBase.CoupledODEs","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\nDifferentialEquations.jl keyword arguments and interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = Tsit5(stagelimiter! = triviallimiter!, steplimiter! = triviallimiter!, thread = static(false)), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling , however the majority of downstream functions in DynamicalSystems.jl assume that f is differentiable.\n\nThe convenience constructor CoupledODEs(prob::ODEProblem, diffeq) and CoupledODEs(ds::CoupledODEs, diffeq) are also available.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the ODEProblem is integ.sol.prob. The convenience syntax ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) is available.\n\n\n\n\n\n","category":"type"},{"location":"#StroboscopicMap","page":"DynamicalSystemsBase.jl","title":"StroboscopicMap","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"StroboscopicMap","category":"page"},{"location":"#DynamicalSystemsBase.StroboscopicMap","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.StroboscopicMap","text":"StroboscopicMap <: DiscreteTimeDynamicalSystem\nStroboscopicMap(ds::CoupledODEs, period::Real) → smap\nStroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)\n\nA discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) CoupledODEs system exactly over a given period. The second signature first creates a CoupledODEs and then calls the first.\n\nStroboscopicMap follows the DynamicalSystem interface. In addition, the function set_period!(smap, period) is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, current_time and initial_time are integers. The initial time is always 0, because current_time counts elapsed periods. Call these functions on the parent of StroboscopicMap to obtain the corresponding continuous time. In contrast, reinit! expects t0 in continuous time.\n\nThe convenience constructor\n\nStroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap\n\nis also provided.\n\nSee also PoincareMap.\n\n\n\n\n\n","category":"type"},{"location":"#PoincareMap","page":"DynamicalSystemsBase.jl","title":"PoincareMap","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"PoincareMap\ncurrent_crossing_time\npoincaresos","category":"page"},{"location":"#DynamicalSystemsBase.PoincareMap","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.PoincareMap","text":"PoincareMap <: DiscreteTimeDynamicalSystem\nPoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap\n\nA discrete time dynamical system that produces iterations over the Poincaré map[DatserisParlitz2022] of the given continuous time ds. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the plane argument.\n\nSee also StroboscopicMap, poincaresos.\n\nKeyword arguments\n\ndirection = -1: Only crossings with sign(direction) are considered to belong to the surface of section. Negative direction means going from less than b to greater than b.\nu0 = nothing: Specify an initial state.\nrootkw = (xrtol = 1e-6, atol = 1e-8): A NamedTuple of keyword arguments passed to find_zero from Roots.jl.\nTmax = 1e3: The argument Tmax exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one step! the system has been evolved for more than Tmax, then step!(pmap) will terminate and error.\n\nDescription\n\nThe Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. PoincareMap iterates over the crossings of the section.\n\nIf the state of ds is mathbfu = (u_1 ldots u_D) then the equation defining a hyperplane is\n\na_1u_1 + dots + a_Du_D = mathbfacdotmathbfu=b\n\nwhere mathbfa b are the parameters of the hyperplane.\n\nIn code, plane can be either:\n\nA Tuple{Int, <: Real}, like (j, r): the plane is defined as when the jth variable of the system equals the value r.\nA vector of length D+1. The first D elements of the vector correspond to mathbfa while the last element is b.\n\nPoincareMap uses ds, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.\n\nPoincareMap follows the DynamicalSystem interface with the following adjustments:\n\ndimension(pmap) == dimension(ds), even though the Poincaré map is effectively 1 dimension less.\nLike StroboscopicMap time is discrete and counts the iterations on the surface of section. initial_time is always 0 and current_time is current iteration number.\nA new function current_crossing_time returns the real time corresponding to the latest crossing of the hyperplane, which is what the current_state(ds) corresponds to as well.\nFor the special case of plane being a Tuple{Int, <:Real}, a special reinit! method is allowed with input state of length D-1 instead of D, i.e., a reduced state already on the hyperplane that is then converted into the D dimensional state.\n\nExample\n\nusing DynamicalSystemsBase\nds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)\npmap = poincaremap(ds, (3, 0.0))\nstep!(pmap)\nnext_state_on_psos = current_state(pmap)\n\n[DatserisParlitz2022]: Datseris & Parlitz 2022, Nonlinear Dynamics: A Concise Introduction Interlaced with Code, Springer Nature, Undergrad. Lect. Notes In Physics\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.current_crossing_time","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_crossing_time","text":"current_crossing_time(pmap::PoincareMap) → tcross\n\nReturn the time of the latest crossing of the Poincare section.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.poincaresos","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.poincaresos","text":"poincaresos(A::AbstractStateSpaceSet, plane; kwargs...) → P::StateSpaceSet\n\nCalculate the Poincaré surface of section of the given dataset with the given plane by performing linear interpolation betweeen points that sandwich the hyperplane.\n\nArgument plane and keywords direction, warning, save_idxs are the same as in PoincareMap.\n\n\n\n\n\npoincaresos(ds::CoupledODEs, plane, T = 1000.0; kwargs...) → P::StateSpaceSet\n\nReturn the iterations of ds on the Poincaré surface of section with the plane, by evolving ds up to a total of T. Return a StateSpaceSet of the points that are on the surface of section.\n\nThis function initializes a PoincareMap and steps it until its current_crossing_time exceeds T. You can also use trajectory with PoincareMap to get a sequence of N::Int points instead.\n\nThe keywords Ttr, save_idxs act as in trajectory. See PoincareMap for plane and all other keywords.\n\n\n\n\n\n","category":"function"},{"location":"#TangentDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"TangentDynamicalSystem","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"CoreDynamicalSystem\nTangentDynamicalSystem\ncurrent_deviations\nset_deviations!\northonormal","category":"page"},{"location":"#DynamicalSystemsBase.CoreDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.CoreDynamicalSystem","text":"CoreDynamicalSystem\n\nUnion type meaning either DeterministicIteratedMap or CoupledODEs, which are the core systems whose dynamic rule f is known analytically.\n\nThis type is used for deciding whether a creation of a TangentDynamicalSystem is possible or not.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.TangentDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.TangentDynamicalSystem","text":"TangentDynamicalSystem <: DynamicalSystem\nTangentDynamicalSystem(ds::CoreDynamicalSystem; kwargs...)\n\nA dynamical system that bundles the evolution of ds (which must be an CoreDynamicalSystem) and k deviation vectors that are evolved according to the dynamics in the tangent space (also called linearized dynamics or the tangent dynamics).\n\nThe state of ds must be an AbstractVector for TangentDynamicalSystem.\n\nTangentDynamicalSystem follows the DynamicalSystem interface with the following adjustments:\n\nreinit! takes an additional keyword Q0 (with same default as below)\nThe additional functions current_deviations and set_deviations! are provided for the deviation vectors.\n\nKeyword arguments\n\nk or Q0: Q0 represents the initial deviation vectors (each column = 1 vector). If k::Int is given, a matrix Q0 is created with the first k columns of the identity matrix. Otherwise Q0 can be given directly as a matrix. It must hold that size(Q, 1) == dimension(ds). You can use orthonormal for random orthonormal vectors. By default k = dimension(ds) is used.\nu0 = current_state(ds): Starting state.\nJ and J0: See section \"Jacobian\" below.\n\nDescription\n\nLet u be the state of ds, and y a deviation (or perturbation) vector. These two are evolved in parallel according to\n\nbeginarrayrcl\nfracdvecxdt = f(vecx) \nfracdYdt = J_f(vecx) cdot Y\nendarray\nquad mathrmorquad\nbeginarrayrcl\nvecx_n+1 = f(vecx_n) \nY_n+1 = J_f(vecx_n) cdot Y_n\nendarray\n\nfor continuous or discrete time respectively. Here f is the dynamic_rule(ds) and J_f is the Jacobian of f.\n\nJacobian\n\nThe keyword J provides the Jacobian function. It must be a Julia function in the same form as f, the dynamic_rule. Specifically, J(u, p, n) -> M::SMatrix for the out-of-place version or J(M, u, p, n) for the in-place version acting in-place on M. in both cases M is a matrix whose columns are the deviation vectors.\n\nBy default J = nothing.  In this case J is constructed automatically using the module ForwardDiff, hence its limitations also apply here. Even though ForwardDiff is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so it is recommended. Additionally, automatic and in-place Jacobians cannot be time dependent.\n\nThe keyword J0 allows you to pass an initialized Jacobian matrix J0. This is useful for large in-place systems where only a few components of the Jacobian change during the time evolution. J0 can be a sparse or any other matrix type. If not given, a matrix of zeros is used. J0 is ignored for out of place systems.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.current_deviations","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_deviations","text":"current_deviations(tands::TangentDynamicalSystem)\n\nReturn the deviation vectors of tands as a matrix with each column a vector.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.set_deviations!","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.set_deviations!","text":"set_deviations!(tands::TangentDynamicalSystem, Q)\n\nSet the deviation vectors of tands to be Q, a matrix with each column a vector.\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.orthonormal","page":"DynamicalSystemsBase.jl","title":"StateSpaceSets.orthonormal","text":"orthonormal([T,] D, k) -> ws\n\nReturn a matrix ws with k columns, each being an D-dimensional orthonormal vector.\n\nT is the return type and can be either SMatrix or Matrix. If not given, it is SMatrix if D*k < 100, otherwise Matrix.\n\n\n\n\n\n","category":"function"},{"location":"#ProjectedDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"ProjectedDynamicalSystem","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ProjectedDynamicalSystem","category":"page"},{"location":"#DynamicalSystemsBase.ProjectedDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.ProjectedDynamicalSystem","text":"ProjectedDynamicalSystem <: DynamicalSystem\nProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)\n\nA dynamical system that represents a projection of an existing ds on a (projected) space.\n\nThe projection defines the projected space. If projection isa AbstractVector{Int}, then the projected space is simply the variable indices that projection contains. Otherwise, projection can be an arbitrary function that given the state of the original system ds, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.\n\ncomplete_state produces the state for the original system from the projected state. complete_state can always be a function that given the projected state returns a state in the original space. However, if projection isa AbstractVector{Int}, then complete_state can also be a vector that contains the values of the remaining variables of the system, i.e., those not contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.\n\nNotice that ProjectedDynamicalSystem does not require an invertible projection, complete_state is only used during reinit!. ProjectedDynamicalSystem is in fact a rather trivial wrapper of ds which steps it as normal in the original state space and only projects as a last step, e.g., during current_state.\n\nExamples\n\nCase 1: project 5-dimensional system to its last two dimensions.\n\nds = Systems.lorenz96(5)\nprojection = [4, 5]\ncomplete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions\npds = ProjectedDynamicalSystem(ds, projection, complete_state)\nreinit!(pds, [0.2, 0.4])\nstep!(pds)\nget_state(pds)\n\nCase 2: custom projection to general functions of state.\n\nds = Systems.lorenz96(5)\nprojection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)]\ncomplete_state(y) = repeat([y[1]/5], 5)\npds = # same as in above example...\n\n\n\n\n\n","category":"type"},{"location":"#ParallelDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"ParallelDynamicalSystem","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ParallelDynamicalSystem\ninitial_states\ncurrent_states","category":"page"},{"location":"#DynamicalSystemsBase.ParallelDynamicalSystem","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.ParallelDynamicalSystem","text":"ParallelDynamicalSystem <: DynamicalSystem\nParallelDynamicalSystem(ds::DynamicalSystem, states::Vector{<:AbstractArray})\n\nA struct that evolves several states of a given dynamical system in parallel at exactly the same times. Useful when wanting to evolve several different trajectories of the same system while ensuring that they share parameters and time vector.\n\nThis struct follows the DynamicalSystem interface with the following adjustments:\n\nThe function current_state is called as current_state(pds, i::Int = 1) which returns the ith state. Same for initial_state.\nSimilarly, set_state! obtains a third argument i::Int = 1 to set the i-th state.\ncurrent_states and initial_states can be used to get all parallel states.\nreinit! takes in a vector of states (like states) for u.\n\n\n\n\n\n","category":"type"},{"location":"#DynamicalSystemsBase.initial_states","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.initial_states","text":"initial_states(pds::ParallelDynamicalSystem)\n\nReturn an iterator over the initial parallel states of pds.\n\n\n\n\n\n","category":"function"},{"location":"#DynamicalSystemsBase.current_states","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.current_states","text":"current_states(pds::ParallelDynamicalSystem)\n\nReturn an iterator over the parallel states of pds.\n\n\n\n\n\n","category":"function"},{"location":"#ArbitrarySteppable","page":"DynamicalSystemsBase.jl","title":"ArbitrarySteppable","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ArbitrarySteppable","category":"page"},{"location":"#DynamicalSystemsBase.ArbitrarySteppable","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.ArbitrarySteppable","text":"ArbitrarySteppable <: DiscreteTimeDynamicalSystem\nArbitrarySteppable(\n    model, step!, extract_state, extract_parameters, reset_model!;\n    isdeterministic = true, set_state = reinit!,\n)\n\nA dynamical system generated by an arbitrary \"model\" that can be stepped in-place with some function step!(model) for 1 step. The state of the model is extracted by the extract_state(model) -> u function The parameters of the model are extracted by the extract_parameters(model) -> p function. The system may be re-initialized, via reinit!, with the reset_model! user-provided function that must have the call signature\n\nreset_model!(model, u, p)\n\ngiven a (potentially new) state u and parameter container p, both of which will default to the initial ones in the reinit! call.\n\nArbitrarySteppable exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. ArbitrarySteppable follows the DynamicalSystem interface with the following adjustments:\n\ninitial_time is always 0, as time counts the steps the model has taken since creation or last reinit! call.\nset_state! is the same as reinit! by default. If not, the keyword argument set_state is a function set_state(model, u) that sets the state of the model to u.\nThe keyword isdeterministic should be set properly, as it decides whether downstream algorithms should error or not.\n\n\n\n\n\n","category":"type"},{"location":"#Parallelization","page":"DynamicalSystemsBase.jl","title":"Parallelization","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Since DynamicalSystems are mutable, one needs to copy them before parallelizing, to avoid having to deal with complicated race conditions etc. The simplest way is with deepcopy. Here is an example block that shows how to parallelize calling some expensive function (e.g., calculating the Lyapunov exponent) over a parameter range using Threads:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ds = DynamicalSystem(f, u, p) # some concrete implementation\nparameters = 0:0.01:1\noutputs = zeros(length(parameters))\n\n# Since `DynamicalSystem`s are mutable, we need to copy to parallelize\nsystems = [deepcopy(ds) for _ in 1:Threads.nthreads()-1]\npushfirst!(systems, ds) # we can save 1 copy\n\nThreads.@threads for i in eachindex(parameters)\n    system = systems[Threads.threadid()]\n    set_parameter!(system, 1, parameters[i])\n    outputs[i] = expensive_function(system, args...)\nend","category":"page"},{"location":"#Examples","page":"DynamicalSystemsBase.jl","title":"Examples","text":"","category":"section"},{"location":"#Iterated-map,-out-of-place","page":"DynamicalSystemsBase.jl","title":"Iterated map, out of place","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Let's make the Hénon map as an example.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"using DynamicalSystemsBase\n\nhenon_rule(x, p, n) = SVector(1.0 - p[1]*x[1]^2 + x[2], p[2]*x[1])\nu0 = zeros(2)\np0 = [1.4, 0.3]\n\nhenon = DeterministicIteratedMap(henon_rule, u0, p0)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"and get a trajectory","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"X, t = trajectory(henon, 10000; Ttr = 100)\nX","category":"page"},{"location":"#Coupled-ODEs,-in-place","page":"DynamicalSystemsBase.jl","title":"Coupled ODEs, in place","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Let's make the Lorenz system Hénon map as an example. The system is small, and therefore should utilize the out of place syntax, but for the case of example, we will use the in-place syntax. We'll also use a high accuracy solver from OrdinaryDiffEq.jl.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"using DynamicalSystemsBase\nusing OrdinaryDiffEq: Vern9\n\n@inbounds function lorenz_rule!(du, u, p, t)\n    σ = p[1]; ρ = p[2]; β = p[3]\n    du[1] = σ*(u[2]-u[1])\n    du[2] = u[1]*(ρ-u[3]) - u[2]\n    du[3] = u[1]*u[2] - β*u[3]\n    return nothing\nend\n\nu0 = [0, 10.0, 0]\np0 = [10, 28, 8/3]\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\n\nlorenz = CoupledODEs(lorenz_rule!, u0, p0; diffeq)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"and get a trajectory","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"X, t = trajectory(lorenz, 1000; Δt = 0.05, Ttr = 10)\nX","category":"page"},{"location":"#Advanced-example","page":"DynamicalSystemsBase.jl","title":"Advanced example","text":"","category":"section"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"This is an advanced example of making an in-place implementation of coupled standard maps. It will utilize a handcoded Jacobian, a sparse matrix for the Jacobinan, a default initial Jacobian matrix, as well as function-like-objects as the dynamic rule.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Coupled standard maps is a deterministic iterated map that can have arbitrary number of equations of motion, since you can couple N standard maps which are 2D maps, like so:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"theta_i = theta_i + p_i \np_i = p_i + k_isin(theta_i) - Gamma leftsin(theta_i+1 - theta_i) + sin(theta_i-1 - theta_i) right","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"To model this, we will make a dedicated struct, which is parameterized on the number of coupled maps:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"struct CoupledStandardMaps{N}\n    idxs::SVector{N, Int}\n    idxsm1::SVector{N, Int}\n    idxsp1::SVector{N, Int}\nend","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"(what these fields are will become apparent later)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"We initialize the struct with the amount of standard maps we want to couple, and we also define appropriate parameters:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"M = 5  # couple number\nu0 = 0.001rand(2M) #initial state\nks = 0.9ones(M) # nonlinearity parameters\nΓ = 1.0 # coupling strength\np = (ks, Γ) # parameter container\n\n# Create struct:\nSV = SVector{M, Int}\nidxs = SV(1:M...) # indexes of thetas\nidxsm1 = SV(circshift(idxs, +1)...)  #indexes of thetas - 1\nidxsp1 = SV(circshift(idxs, -1)...)  #indexes of thetas + 1\n# So that:\n# x[i] ≡ θᵢ\n# x[[idxsp1[i]]] ≡ θᵢ+₁\n# x[[idxsm1[i]]] ≡ θᵢ-₁\ncsm = CoupledStandardMaps{M}(idxs, idxsm1, idxsp1)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"We will now use this struct to define a function-like-object, a Type that also acts as a function","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"function (f::CoupledStandardMaps{N})(xnew::AbstractVector, x, p, n) where {N}\n    ks, Γ = p\n    @inbounds for i in f.idxs\n\n        xnew[i+N] = mod2pi(\n            x[i+N] + ks[i]*sin(x[i]) -\n            Γ*(sin(x[f.idxsp1[i]] - x[i]) + sin(x[f.idxsm1[i]] - x[i]))\n        )\n\n        xnew[i] = mod2pi(x[i] + xnew[i+N])\n    end\n    return nothing\nend","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"We will use the same struct to create a function for the Jacobian:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"function (f::CoupledStandardMaps{M})(\n    J::AbstractMatrix, x, p, n) where {M}\n\n    ks, Γ = p\n    # x[i] ≡ θᵢ\n    # x[[idxsp1[i]]] ≡ θᵢ+₁\n    # x[[idxsm1[i]]] ≡ θᵢ-₁\n    @inbounds for i in f.idxs\n        cosθ = cos(x[i])\n        cosθp= cos(x[f.idxsp1[i]] - x[i])\n        cosθm= cos(x[f.idxsm1[i]] - x[i])\n        J[i+M, i] = ks[i]*cosθ + Γ*(cosθp + cosθm)\n        J[i+M, f.idxsm1[i]] = - Γ*cosθm\n        J[i+M, f.idxsp1[i]] = - Γ*cosθp\n        J[i, i] = 1 + J[i+M, i]\n        J[i, f.idxsm1[i]] = J[i+M, f.idxsm1[i]]\n        J[i, f.idxsp1[i]] = J[i+M, f.idxsp1[i]]\n    end\n    return nothing\nend","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"This is possible because the system state is a Vector while the Jacobian is a Matrix, so multiple dispatch can differentiate between the two.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Notice in addition, that the Jacobian function accesses only half the elements of the matrix. This is intentional, and takes advantage of the fact that the other half is constant. We can leverage this further, by making the Jacobian a sparse matrix. Because the DynamicalSystem constructors allow us to give in a pre-initialized Jacobian matrix, we take advantage of that and create:","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"using SparseArrays\nJ = zeros(eltype(u0), 2M, 2M)\n# Set ∂/∂p entries (they are eye(M,M))\n# And they dont change they are constants\nfor i in idxs\n    J[i, i+M] = 1\n    J[i+M, i+M] = 1\nend\nsparseJ = sparse(J)\n\ncsm(sparseJ, u0, p, 0) # apply Jacobian to initial state\nsparseJ","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Now we are ready to create our dynamical system","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"ds = DeterministicIteratedMap(csm, u0, p)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"Of course, the reason we went through all this trouble was to make a TangentDynamicalSystem, that can actually use the Jacobian function.","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"tands = TangentDynamicalSystem(ds; J = csm, J0 = sparseJ, k = M)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"step!(tands, 5)\ncurrent_deviations(tands)","category":"page"},{"location":"","page":"DynamicalSystemsBase.jl","title":"DynamicalSystemsBase.jl","text":"(the deviation vectors will increase in magnitude rapidly because the dynamical system is chaotic)","category":"page"}]
}
